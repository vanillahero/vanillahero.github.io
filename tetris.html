<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
<style>

:root {
  --primary-color: #00ffff;
  --secondary-color: #ff00ff;
  --score-color: #00ff00;
  --reward-color: #ffff00;
  --dark-bg: #000000;
  --black-bg: #000000;
  --text-color: #e0e0e0;
  --game-over-color: #ff0000;
}

body {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background-color: #121212;
  color: var(--text-color);
  overflow: hidden;
  font-family: 'Courier New', Courier, monospace;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

.game-container {
  display: flex;
  gap: 3vh;
  background-color: var(--dark-bg);
  padding: 1vh;
  border-radius: 2vh;
  box-shadow: 0 0 5vh rgba(0, 255, 255, 0.6),
    0 0 2.5vh rgba(0, 255, 255, 0.4) inset;
  border: 0.4vh solid var(--primary-color);
  position: relative;
}

.game-container.paused::before {
  content: attr(data-pause-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 10vh;
  color: var(--reward-color);
  background-color: rgba(15, 15, 28, 0.85);
  text-shadow: 0 0 2vh var(--reward-color);
  z-index: 200;
  border-radius: 2vh;
  pointer-events: none;
}

canvas#gameCanvas {
  background-color: var(--black-bg);
  border: 0.3vh solid var(--primary-color);
  box-shadow: 0 0 2.5vh rgba(0, 255, 255, 0.5);
  display: block;
}

.info-panel,
.highscore-panel {
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  width: 30vh;
  padding: 2vh;
  background-color: var(--dark-bg);
  border-radius: 1.5vh;
}

.info-panel {
  border: 0.3vh solid var(--secondary-color);
  box-shadow: 0 0 3vh rgba(255, 0, 255, 0.6),
    0 0 1.5vh rgba(255, 0, 255, 0.4) inset;
}

.highscore-panel {
  border: 0.3vh solid var(--score-color);
  box-shadow: 0 0 3vh rgba(0, 255, 0, 0.6),
    0 0 1.5vh rgba(0, 255, 0, 0.4) inset;
}

.highscore-panel h1 {
  text-align: center;
  font-size: 4vh;
  color: var(--primary-color);
  text-shadow: 0 0 1vh var(--primary-color);
  margin: 0 0 1.5vh 0;
}

.highscore-panel h2 {
  font-size: 3.6vh;
  color: var(--score-color);
  text-shadow: 0 0 1vh var(--score-color);
  margin: 0 0 1.5vh 0;
}

.highscore-panel ol {
  text-align: left;
  width: 50%;
  padding-left: 1vh;
  margin: 0;
  font-size: 2.5vh;
  color: var(--text-color);
  list-style-type: decimal;
}

.highscore-panel li {
  margin-bottom: 0.8vh;
  text-shadow: 0 0 0.5vh var(--primary-color);
  text-align: right;
}

.info-section {
  width: 100%;
  text-align: center;
  margin-bottom: 1.5vh;
}

.info-section h2 {
  font-size: 3.4vh;
  color: var(--score-color);
  text-shadow: 0 0 1vh var(--score-color);
  margin: 0 0 0.5vh 0;
}

.info-section p {
  font-size: 4.5vh;
  color: var(--primary-color);
  text-shadow: 0 0 0.8vh var(--primary-color);
  margin: 0;
}

#nextPieceCanvas {
  background-color: #050505;
  border: 0.2vh solid var(--score-color);
  box-shadow: 0 0 1.5vh rgba(0, 255, 0, 0.5);
  margin-top: 1vh;
  margin-bottom: 2vh;
  width: 100%;
  height: 12vh;
}

.reward-window {
  width: 100%;
  height: 25vh;
  background-color: var(--black-bg);
  border: 0.4vh solid var(--reward-color);
  box-shadow: 0 0 3vh rgba(255, 255, 0, 0.6),
    0 0 1.5vh rgba(255, 255, 0, 0.4) inset;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
  border-radius: 1vh;
  margin-top: auto;
}

#rewardEmoji {
  font-size: 16vh;
  line-height: 1;
}

@keyframes pop-in {
  from {
    transform: scale(0.1) rotate(-45deg);
    opacity: 0;
  }

  to {
    transform: scale(1) rotate(0deg);
    opacity: 1;
  }
}

.pop-in-animation {
  animation: pop-in 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.game-over-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.85);
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  font-size: 7vh;
  color: var(--game-over-color);
  text-shadow: 0 0 2vh var(--game-over-color);
  z-index: 100;
  border-radius: 1.8vh;
  text-align: center;
}

.game-over-screen button {
  background-color: var(--score-color);
  color: var(--dark-bg);
  border: 0.3vh solid #00cc00;
  padding: 2vh 4vh;
  font-family: 'Courier New', Courier, monospace;
  font-size: 2.5vh;
  cursor: pointer;
  border-radius: 1vh;
  box-shadow: 0 0 1.5vh rgba(0, 255, 0, 0.7);
  transition: transform 0.2s, box-shadow 0.2s;
  margin-top: 3vh;
}

.game-over-screen button:hover {
  transform: scale(1.05);
  box-shadow: 0 0 2.5vh rgba(0, 255, 0, 1);
}

#resetHighscoreButton {
  background-color: var(--game-over-color);
  color: var(--text-color);
  border: 0.3vh solid #cc0000;
  padding: 1.5vh 3vh;
  font-family: 'Courier New', Courier, monospace;
  font-size: 2.2vh;
  cursor: pointer;
  border-radius: 1vh;
  box-shadow: 0 0 1.5vh rgba(255, 0, 0, 0.7);
  transition: transform 0.2s, box-shadow 0.2s;
  margin-top: auto;
}

#resetHighscoreButton:hover {
  transform: scale(1.05);
  box-shadow: 0 0 2.5vh rgba(255, 0, 0, 1);
}

#controls {
  width: 100%;
  margin-top: 2vh;
  font-size: 2vh;
  color: var(--secondary-color);
  opacity: 0.8;
}

#controls div {
  display: flex;
  align-items: center;
  margin-bottom: 0.8vh;
}

#controls span.key {
  display: inline-block;
  background-color: #222;
  border: 1px solid var(--secondary-color);
  border-radius: 0.5vh;
  padding: 0.3vh 1vh;
  margin-right: 1.5vh;
  font-weight: bold;
  color: var(--text-color);
  min-width: 4vh;
  text-align: center;
}

</style>
  </head>
  <body>
    <div class="game-container">
      <div class="info-panel">
        <div class="info-section">
          <h2 id="score-label"></h2>
          <p id="score">0</p>
        </div>
        <div class="info-section">
          <h2 id="level-label"></h2>
          <p id="level">1</p>
        </div>
        <div class="info-section">
          <h2 id="next-label"></h2>
          <canvas id="nextPieceCanvas"></canvas>
          <div id="controls">
            <div id="controls-move"><span class="key">‚Üê ‚Üí</span><span class="action-text"></span></div>
            <div id="controls-rotate"><span class="key">‚Üë</span><span class="action-text"></span></div>
            <div id="controls-speed"><span class="key">‚Üì</span><span class="action-text"></span></div>
            <div id="controls-drop"><span class="key">Space</span><span class="action-text"></span></div>
            <div id="controls-pause"><span class="key">P</span><span class="action-text"></span></div>
          </div>
        </div>
        <div class="reward-window">
          <div id="rewardEmoji" aria-label="Reward Emoji"></div>
        </div>
      </div>
      <canvas id="gameCanvas"></canvas>
      <div class="highscore-panel">
        <p style="margin: 0 0 10px 0; font-size: 1rem; color: #505050;">&copy; Johnny Heggelund</p>
        <h1 id="main-title" style="margin: 0;"></h1>
        <h2 id="highscore-title"></h2>
        <ol id="highscore-list"></ol>
        <button id="resetHighscoreButton"></button>
      </div>
      <div class="game-over-screen" id="gameStatusScreen">
        <div id="statusMessage"></div>
        <button id="statusButton"></button>
      </div>
    </div>
<script>

const lang = {
  title: "Tetris Neon",
  score: "Score",
  level: "Level",
  next: "Next",
  controlsMove: "Move",
  controlsRotate: "Rotate",
  controlsSpeed: "Speed Up",
  controlsDrop: "Drop",
  controlsPause: "Pause",
  highscoreTitle: "High Scores",
  resetScores: "Reset Scores",
  welcome: "Welcome to Tetris",
  startGame: "Start Game",
  gameOver: "GAME OVER!",
  playAgain: "Play Again",
  pauseOverlay: "PAUSED",
  noHighscores: "No high scores yet"
};
const gameCanvas = document.getElementById('gameCanvas');
const ctx = gameCanvas.getContext('2d');
const nextPieceCanvas = document.getElementById('nextPieceCanvas');
const nextPieceCtx = nextPieceCanvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const levelDisplay = document.getElementById('level');
const rewardEmojiDisplay = document.getElementById('rewardEmoji');
const gameStatusScreen = document.getElementById('gameStatusScreen');
const statusMessage = document.getElementById('statusMessage');
const statusButton = document.getElementById('statusButton');
const gameContainer = document.querySelector('.game-container');
const highscoreList = document.getElementById('highscore-list');
const resetHighscoreButton = document.getElementById('resetHighscoreButton');
const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 20;
const HIGHSCORE_KEY = 'tetrisHighscores';
const TETROMINOES = [
  [
    [0, 0, 0, 0],
    [1, 1, 1, 1],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
  ],
  [
    [1, 0, 0],
    [1, 1, 1],
    [0, 0, 0]
  ],
  [
    [0, 0, 1],
    [1, 1, 1],
    [0, 0, 0]
  ],
  [
    [1, 1],
    [1, 1]
  ],
  [
    [0, 1, 1],
    [1, 1, 0],
    [0, 0, 0]
  ],
  [
    [0, 1, 0],
    [1, 1, 1],
    [0, 0, 0]
  ],
  [
    [1, 1, 0],
    [0, 1, 1],
    [0, 0, 0]
  ],
];
const COLORS = ['#00ffff', '#0000ff', '#ff8c00', '#ffff00', '#00ff00', '#ff00ff', '#ff0000'];
const EMOJI_REWARDS = [
  'üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ', 'üêî', 'üêß', 'üê¶',
  'ü¶â', 'üêò', 'üåù', 'üåπ', 'üçÑ', 'üçá', 'üçâ', 'üçå', 'üçí', 'üçì', 'üçî', 'üçï', 'üçú', 'üçü', 'üç¶', 'üç®', 'üç©', 'üç´',
  'üç¨', 'üç≠', 'üç∞', 'üçπ', 'üçæ', 'üçø', 'üéÅ', 'üéà', 'üéâ', 'üé©', 'üé≠', 'üé∑', 'üé∏', 'üí£', 'üí•', 'üí∞', 'üï∫', 'üóø',
  'üöÄ', 'üöÅ', 'üöÇ', 'üöî', 'üöñ', 'üöò', 'üöú', 'üö¢', 'üö≤', 'üöΩ', 'üõÄ', 'üõµ', 'üõ∂', 'üõ∑', 'üõ∏', 'üõπ',
  'üõ∫', 'üõª', 'üõº', 'ü§ñ', 'ü§†', 'ü§π', 'ü•Å', 'ü•ù', 'ü•ï', 'ü•û', 'ü••', 'ü•¶', 'ü•®', 'ü¶Ä', 'ü¶É', 'ü¶Ñ', 'ü¶Ö',
  'ü¶á', 'ü¶à', 'ü¶ã', 'ü¶å', 'ü¶ç', 'ü¶é', 'ü¶í', 'ü¶ú', 'ü•â', 'ü•à', 'ü•á',
];
let blockSize;
let previewBlockSize;
let board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
let currentPiece = null;
let nextPiece = null;
let score = 0;
let level = 1;
let fallInterval = 1000;
let gameLoop;
let isGameOver = false;
let isPaused = false;
let resizeTimer;

function updateStaticUIText() {
  document.title = lang.title;
  document.getElementById('score-label').textContent = lang.score;
  document.getElementById('level-label').textContent = lang.level;
  document.getElementById('next-label').textContent = lang.next;
  document.querySelector('#controls-move .action-text').textContent = lang.controlsMove;
  document.querySelector('#controls-rotate .action-text').textContent = lang.controlsRotate;
  document.querySelector('#controls-speed .action-text').textContent = lang.controlsSpeed;
  document.querySelector('#controls-drop .action-text').textContent = lang.controlsDrop;
  document.querySelector('#controls-pause .action-text').textContent = lang.controlsPause;
  document.getElementById('main-title').textContent = lang.title;
  document.getElementById('highscore-title').textContent = lang.highscoreTitle;
  document.getElementById('resetHighscoreButton').textContent = lang.resetScores;
  gameContainer.dataset.pauseText = lang.pauseOverlay;
}

function setGameScale() {
  const heightScale = 0.9;
  const totalHeight = window.innerHeight * heightScale;
  blockSize = Math.floor(totalHeight / BOARD_HEIGHT);
  gameCanvas.height = blockSize * BOARD_HEIGHT;
  gameCanvas.width = blockSize * BOARD_WIDTH;
  previewBlockSize = blockSize * 0.7;
  nextPieceCanvas.width = nextPieceCanvas.clientWidth;
  nextPieceCanvas.height = nextPieceCanvas.clientHeight;
}

function initializeGame() {
  board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
  score = 0;
  level = 1;
  fallInterval = 1000;
  isGameOver = false;
  scoreDisplay.textContent = score;
  levelDisplay.textContent = level;
  gameStatusScreen.style.display = 'none';
  updateRewardEmoji();
}

function showStartScreen() {
  statusMessage.textContent = lang.welcome;
  statusButton.textContent = lang.startGame;
  gameStatusScreen.style.display = 'flex';
}

function createPiece() {
  const typeId = Math.floor(Math.random() * TETROMINOES.length);
  const shape = TETROMINOES[typeId];
  return {
    shape: shape,
    x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),
    y: 0,
    type: typeId,
  };
}

function isValidMove(piece, offsetX, offsetY, shape) {
  const shapeToCheck = shape || piece.shape;
  for (let row = 0; row < shapeToCheck.length; row++) {
    for (let col = 0; col < shapeToCheck[row].length; col++) {
      if (shapeToCheck[row][col]) {
        const newX = piece.x + col + offsetX;
        const newY = piece.y + row + offsetY;
        if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return false;
        if (newY < 0) continue;
        if (board[newY][newX] > 0) return false;
      }
    }
  }
  return true;
}

function rotate(piece) {
  const originalShape = piece.shape;
  const newShape = originalShape[0].map((_, colIndex) =>
    originalShape.map((row) => row[colIndex]).reverse()
  );
  if (isValidMove(piece, 0, 0, newShape)) {
    piece.shape = newShape;
    return;
  }
  const kicks = [
    [-1, 0],
    [1, 0],
    [0, -1],
    [-1, -1],
    [1, -1]
  ];
  for (const [kx, ky] of kicks) {
    if (isValidMove(piece, kx, ky, newShape)) {
      piece.shape = newShape;
      piece.x += kx;
      piece.y += ky;
      return;
    }
  }
}

function freezePiece() {
  for (let row = 0; row < currentPiece.shape.length; row++) {
    for (let col = 0; col < currentPiece.shape[row].length; col++) {
      if (currentPiece.shape[row][col]) {
        if (currentPiece.y + row < 0) {
          endGame();
          return;
        }
        board[currentPiece.y + row][currentPiece.x + col] = currentPiece.type + 1;
      }
    }
  }
}

function clearRows() {
  let rowsCleared = 0;
  for (let row = BOARD_HEIGHT - 1; row >= 0; row--) {
    if (board[row].every((cell) => cell > 0)) {
      rowsCleared++;
      board.splice(row, 1);
      board.unshift(Array(BOARD_WIDTH).fill(0));
      row++;
    }
  }
  if (rowsCleared > 0) {
    updateScore(rowsCleared);
  }
}

function dropPiece() {
  if (isGameOver || isPaused) return;
  if (isValidMove(currentPiece, 0, 1)) {
    currentPiece.y++;
  } else {
    freezePiece();
    clearRows();
    if (!isGameOver) {
      currentPiece = nextPiece;
      nextPiece = createPiece();
      drawNextPiece();
      if (!isValidMove(currentPiece, 0, 0)) {
        endGame();
      }
    }
  }
  drawGame();
}

function hardDrop() {
  if (isGameOver || isPaused || !currentPiece) return;
  let rowsDropped = 0;
  while (isValidMove(currentPiece, 0, 1)) {
    currentPiece.y++;
    rowsDropped++;
  }
  score += rowsDropped * 2;
  scoreDisplay.textContent = score;
  dropPiece();
}

function gameLoopTick() {
  dropPiece();
}

function updateScore(lines) {
  const pointsPerLine = [0, 100, 300, 500, 800];
  score += pointsPerLine[lines] * level;
  scoreDisplay.textContent = score;
  updateLevel();
  updateRewardEmoji();
}

function updateLevel() {
  const pointsForNextLevel = 3000;
  const newLevel = Math.floor(score / pointsForNextLevel) + 1;
  if (newLevel > level) {
    level = newLevel;
    levelDisplay.textContent = level;
    const speedIncrease = 40;
    const maxSpeed = 250;
    fallInterval = Math.max(maxSpeed, fallInterval - speedIncrease);
    clearInterval(gameLoop);
    gameLoop = setInterval(gameLoopTick, fallInterval);
  }
}

function updateRewardEmoji() {
  const pointsPerEmoji = 3000;
  const emojiIndex = Math.min(Math.floor(score / pointsPerEmoji), EMOJI_REWARDS.length - 1);
  const newEmoji = EMOJI_REWARDS[emojiIndex];
  if (rewardEmojiDisplay.textContent !== newEmoji) {
    rewardEmojiDisplay.textContent = newEmoji;
    rewardEmojiDisplay.classList.remove('pop-in-animation');
    void rewardEmojiDisplay.offsetWidth;
    rewardEmojiDisplay.classList.add('pop-in-animation');
  }
}

function getHighscores() {
  const scores = localStorage.getItem(HIGHSCORE_KEY);
  return scores ? JSON.parse(scores) : [];
}

function saveHighscores(scores) {
  localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(scores));
}

function addHighscore(newScore) {
  if (newScore === 0) return;
  const scores = getHighscores();
  scores.push(newScore);
  scores.sort((a, b) => b - a);
  const top10Scores = scores.slice(0, 10);
  saveHighscores(top10Scores);
}

function displayHighscores() {
  const scores = getHighscores();
  highscoreList.innerHTML = '';
  if (scores.length === 0) {
    const li = document.createElement('li');
    li.textContent = lang.noHighscores;
    li.style.listStyleType = 'none';
    li.style.textAlign = 'center';
    highscoreList.appendChild(li);
  } else {
    scores.forEach((score) => {
      const li = document.createElement('li');
      li.textContent = score;
      highscoreList.appendChild(li);
    });
  }
}

function resetHighscores() {
  localStorage.removeItem(HIGHSCORE_KEY);
  displayHighscores();
}

function drawBlock(x, y, typeId, context, currentBlockSize, isShadow = false) {
  context.save();
  const color = COLORS[typeId];
  const px = x * currentBlockSize;
  const py = y * currentBlockSize;
  if (isShadow) {
    context.globalAlpha = 0.3;
    context.strokeStyle = color;
    context.lineWidth = 2;
    context.strokeRect(px, py, currentBlockSize, currentBlockSize);
  } else {
    context.fillStyle = color;
    context.shadowColor = color;
    context.shadowBlur = 8;
    context.fillRect(px, py, currentBlockSize, currentBlockSize);
    context.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    context.lineWidth = 1;
    context.strokeRect(px, py, currentBlockSize, currentBlockSize);
  }
  context.restore();
}

function findShadowPosition(piece) {
  let y = piece.y;
  while (isValidMove(piece, 0, y - piece.y + 1)) {
    y++;
  }
  return y;
}

function drawPiece(piece, context, currentBlockSize, isShadow = false) {
  const shape = piece.shape;
  for (let row = 0; row < shape.length; row++) {
    for (let col = 0; col < shape[row].length; col++) {
      if (shape[row][col]) {
        drawBlock(piece.x + col, piece.y + row, piece.type, context, currentBlockSize, isShadow);
      }
    }
  }
}

function drawBoard() {
  for (let row = 0; row < BOARD_HEIGHT; row++) {
    for (let col = 0; col < BOARD_WIDTH; col++) {
      if (board[row][col] > 0) {
        const typeId = board[row][col] - 1;
        drawBlock(col, row, typeId, ctx, blockSize);
      }
    }
  }
}

function drawGame() {
  ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
  drawBoard();
  if (currentPiece) {
    const shadowY = findShadowPosition(currentPiece);
    drawPiece({
      ...currentPiece,
      y: shadowY
    }, ctx, blockSize, true);
    drawPiece(currentPiece, ctx, blockSize, false);
  }
}

function drawNextPiece() {
  nextPieceCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
  if (nextPiece) {
    const shape = nextPiece.shape;
    const pieceWidth = shape[0].length * previewBlockSize;
    const pieceHeight = shape.length * previewBlockSize;
    const startX = (nextPieceCanvas.width - pieceWidth) / 2;
    const startY = (nextPieceCanvas.height - pieceHeight) / 2;
    const previewPiece = {
      ...nextPiece,
      x: startX / previewBlockSize,
      y: startY / previewBlockSize,
    };
    drawPiece(previewPiece, nextPieceCtx, previewBlockSize);
  }
}

function restartGame() {
  initializeGame();
  currentPiece = createPiece();
  nextPiece = createPiece();
  drawNextPiece();
  drawGame();
  if (gameLoop) clearInterval(gameLoop);
  gameLoop = setInterval(gameLoopTick, fallInterval);
}

function endGame() {
  isGameOver = true;
  clearInterval(gameLoop);
  statusMessage.textContent = lang.gameOver;
  statusButton.textContent = lang.playAgain;
  gameStatusScreen.style.display = 'flex';
  addHighscore(score);
  displayHighscores();
}

function togglePause() {
  if (isGameOver) return;
  isPaused = !isPaused;
  if (isPaused) {
    clearInterval(gameLoop);
    gameContainer.classList.add('paused');
  } else {
    gameLoop = setInterval(gameLoopTick, fallInterval);
    gameContainer.classList.remove('paused');
  }
}

function handleKeyDown(e) {
  if (e.key.toLowerCase() === 'p') {
    togglePause();
    return;
  }
  if (isGameOver || !currentPiece || isPaused) return;
  let handled = true;
  switch (e.key) {
    case 'ArrowLeft':
      if (isValidMove(currentPiece, -1, 0)) currentPiece.x--;
      break;
    case 'ArrowRight':
      if (isValidMove(currentPiece, 1, 0)) currentPiece.x++;
      break;
    case 'ArrowDown':
      if (isValidMove(currentPiece, 0, 1)) {
        currentPiece.y++;
        score += 1;
        scoreDisplay.textContent = score;
      }
      break;
    case 'ArrowUp':
      rotate(currentPiece);
      break;
    case ' ':
      e.preventDefault();
      hardDrop();
      break;
    default:
      handled = false;
      break;
  }
  if (handled) drawGame();
}

function onWindowResize() {
  setGameScale();
  drawGame();
  drawNextPiece();
}
document.addEventListener('keydown', handleKeyDown);
statusButton.addEventListener('click', restartGame);
resetHighscoreButton.addEventListener('click', resetHighscores);
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(onWindowResize, 150);
});

function init() {
  updateStaticUIText();
  setGameScale();
  displayHighscores();
  showStartScreen();
}
init();
(function() {
  const hideStyle = 'cursor: none !important;';
  const showStyle = 'cursor: default !important;';
  const setCursor = (style) => {
    document.documentElement.style.cssText += style;
    document.body.style.cssText += style;
    document.querySelectorAll('canvas, iframe, object, embed').forEach(el => {
      el.style.cssText += style;
    });
  };
  window.addEventListener('keydown', () => setCursor(hideStyle), true);
  window.addEventListener('mousemove', () => setCursor(showStyle), true);
})();

</script>
</body>
</html>