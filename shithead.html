<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shithead</title>
<style>

:root {
  --felt-green: #2a3d2a;
  --dark-green: #1a241a;
  --wood-brown: #5d3a1a;
  --panel-bg: #1f1f1f;
  --panel-bg-dark: rgba(0, 0, 0, 0.3);
  --text-color: #e0e0e0;
  --text-color-dark: #333;
  --accent-color: #ffc857;
  --red-color: #e57373;
  --green-color: #4caf50;
  --card-bg: #fdfdfd;
  --shadow-light: rgba(0, 0, 0, 0.25);
  --shadow-dark: rgba(0, 0, 0, 0.6);
  --font-heading: 'Verdana', 'Segoe UI', sans-serif;
  --font-body: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
}

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  font-size: clamp(14px, 1.5vmin, 18px);
}

body {
  background-color: var(--dark-green);
  color: var(--text-color);
  font-family: var(--font-body);
  overflow: hidden;
  overscroll-behavior: contain;
  height: 100vh;
  width: 100vw;
}

h1,
h2,
h3 {
  font-family: var(--font-heading);
  color: var(--accent-color);
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 1px;
}

h1 {
  font-size: 2.5rem;
  text-shadow: 2px 2px 4px var(--shadow-dark);
}

h2 {
  font-size: 1.8rem;
}

h3 {
  font-size: 1.2rem;
  color: var(--text-color);
}

button {
  font-family: var(--font-heading);
  font-size: 1.2rem;
  font-weight: 600;
  padding: 0.8rem 1.5rem;
  background-color: var(--green-color);
  color: #ffffff;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.3s, transform 0.1s;
  box-shadow: 0 4px 6px var(--shadow-light);
  text-transform: uppercase;
}

button:hover {
  background-color: #5cb85c;
}

button:active {
  transform: translateY(2px);
  box-shadow: 0 2px 3px var(--shadow-light);
}

button:disabled {
  background-color: #616161;
  cursor: not-allowed;
}

.container {
  display: flex;
  flex-direction: column;
  width: 100vw;
  height: 100vh;
}

.main-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.right-panel {
  background-color: var(--panel-bg);
  color: var(--text-color);
  display: flex;
  flex-direction: column;
  width: 100%;
  flex-shrink: 0;
  box-shadow: 0 -4px 10px var(--shadow-dark);
  max-height: 40%;
  z-index: 50;
}

.panel-header {
  padding: 0.75rem;
  background-color: #2a2a2a;
  border-bottom: 1px solid #444;
  text-align: center;
}

.panel-body {
  padding: 1rem;
  overflow-y: auto;
  flex-grow: 1;
  font-size: 0.9rem;
  line-height: 1.6;
}

#info-panel-body p {
  padding-bottom: 0.5rem;
  margin-bottom: 0.5rem;
  border-bottom: 1px solid #444;
  word-wrap: break-word;
}

#info-panel-body p:last-child {
  border-bottom: none;
}

@media (min-width: 768px) and (min-aspect-ratio: 4/3) {
  .container {
    flex-direction: row;
  }

  .right-panel {
    border-left: 2px solid #333;
    width: 280px;
    max-height: 100%;
    box-shadow: -4px 0 10px var(--shadow-dark);
  }
}

.game-status-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  color: #ffffff;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  z-index: 100;
  padding: 1rem;
  gap: 1.5rem;
}

.game-status-overlay .status-text {
  font-family: var(--font-body);
  font-size: 1.2rem;
  max-width: 500px;
  line-height: 1.5;
}

#game-table {
  background-color: var(--felt-green);
  background-image: radial-gradient(rgba(255, 255, 255, 0.03) 15%,
      transparent 15%);
  background-size: 20px 20px;
  border: 1vmin solid var(--wood-brown);
  border-radius: 1.5vmin;
  margin: 2vmin;
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 2vmin;
  position: relative;
  box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
}

.player-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5vmin;
}

.player-info {
  font-family: var(--font-heading);
  font-size: 1.1rem;
  font-weight: 600;
  padding: 0.5rem 1rem;
  background-color: var(--panel-bg-dark);
  color: #ffffff;
  border-radius: 8px;
  z-index: 20;
  transition: all 0.3s ease-in-out;
}

.player-info.active-turn {
  color: var(--accent-color);
  box-shadow: 0 0 15px var(--accent-color);
  transform: scale(1.1);
}

#play-area {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 2vmin;
  padding: 1vmin 0;
}

.cards-area {
  display: flex;
  justify-content: center;
  align-items: flex-end;
  gap: 1.2vmin;
  min-height: 12vmin;
}

.card {
  width: 8.5vmin;
  aspect-ratio: 2.5 / 3.5;
  border: 1px solid #bbb;
  background-color: var(--card-bg);
  border-radius: 0.8vmin;
  box-shadow: 0.3vmin 0.3vmin 0.6vmin var(--shadow-dark);
  font-family: var(--font-heading);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  font-size: 2.5vmin;
  font-weight: 600;
  position: relative;
  flex-shrink: 0;
  transition: transform 0.2s ease-out, box-shadow 0.2s;
  user-select: none;
  color: var(--text-color-dark);
}

.card.face-down {
  background-image: radial-gradient(circle at 25% 25%,
      #a00 5%,
      transparent 5.1%),
    radial-gradient(circle at 75% 75%, #a00 5%, transparent 5.1%),
    linear-gradient(45deg, #d62828 50%, #900 50%);
  background-size: 2vmin 2vmin, 2vmin 2vmin, 100% 100%;
  color: transparent;
}

.card-value {
  font-size: 1.2em;
}

.card-suit {
  font-size: 1em;
  line-height: 1;
}

.card-pile {
  width: calc(8.5vmin + 1vmin);
  aspect-ratio: 2.5 / 3.5;
  border: 3px dashed rgba(255, 255, 255, 0.4);
  border-radius: 0.8vmin;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 1rem;
  font-family: var(--font-heading);
  color: rgba(255, 255, 255, 0.7);
  position: relative;
  transition: all 0.3s;
}

.card-pile .card {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 1;
}

#discard-pile.pickup-enabled {
  cursor: pointer;
  border-style: solid;
  border-color: var(--accent-color);
  box-shadow: 0 0 15px var(--accent-color);
}

#deck-pile-count {
  position: absolute;
  bottom: 5px;
  font-size: 0.9rem;
  background-color: var(--panel-bg-dark);
  color: #ffffff;
  padding: 2px 5px;
  border-radius: 5px;
}

.table-cards {
  display: flex;
  gap: 1.2vmin;
}

.table-card-pile {
  position: relative;
  width: 8.5vmin;
  aspect-ratio: 2.5 / 3.5;
}

.table-card-pile .card {
  position: absolute;
  top: 0;
  left: 0;
}

.table-card-pile .card.face-up {
  transform: translate(-0.5vmin, -0.5vmin);
}

.hand-container {
  display: flex;
  align-items: flex-end;
  justify-content: center;
  width: 100%;
  max-width: 95%;
  position: relative;
  z-index: 25;
}

.scroll-button {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  z-index: 30;
  background-color: rgba(0, 0, 0, 0.4);
  color: white;
  border: none;
  font-size: 2.5vmin;
  padding: 1vmin 1.5vmin;
  border-radius: 8px;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity 0.2s, background-color 0.2s;
  display: none;
}

#scroll-left {
  left: -3vmin;
}

#scroll-right {
  right: -3vmin;
}

.scroll-button:hover {
  opacity: 1;
  background-color: rgba(0, 0, 0, 0.6);
}

.scroll-button:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

#player-hand {
  display: flex;
  flex-wrap: nowrap;
  padding: 1vmin 0.5vmin 2vmin 0.5vmin;
  align-items: flex-end;
  min-height: calc(11.9vmin + 3vmin);
  width: 100%;
  scroll-behavior: smooth;
  justify-content: center;
}

#player-hand .card {
  cursor: pointer;
  margin-left: -2.5vmin;
  transition: transform 0.2s ease-out, box-shadow 0.2s, margin-left 0.2s;
}

#player-hand .card:first-child {
  margin-left: 0;
}

#player-hand .card:hover {
  transform: translateY(-2vmin) scale(1.1);
  position: relative;
  z-index: 60;
  box-shadow: 0.5vmin 0.5vmin 1vmin var(--shadow-dark);
}

</style>
  </head>
  <body>
    <div class="container">
      <main class="main-content">
        <div id="game-status-overlay" class="game-status-overlay" align="center">
          <h1>Shithead Card Game</h1>
          <p class="status-text"></p>
          <button id="start-game-btn"></button>
        </div>
        <div id="game-table"></div>
      </main>
      <aside class="right-panel">
        <div class="panel-header">
          <h3 id="info-panel-header"></h3>
        </div>
        <div id="info-panel-body" class="panel-body">
        </div>
      </aside>
    </div>
<script>

const lang = {
  gameTitle: "Shithead",
  playButton: "Play vs. Computer",
  rulesTitle: "RULES",
  logTitle: "LOG",
  pileLabel: "PILE",
  playerName: "Player",
  aiName: "Computer",
  rulesGoal: "<strong>Goal:</strong> Be the first to get rid of all your cards. The last player with cards left is the Shithead!",
  rulesGameplay: "<strong>Gameplay:</strong> Play a card of equal or higher value than the top card on the pile. If you can't play, you must pick up the entire pile.",
  rulesCardOrder: "<strong>Card Order:</strong> (Lowest to highest) 3, 4, 5, 6, 7, 8, 9, J, Q, K, A.",
  rulesSpecialCards: "<strong>Special Cards:</strong>",
  rulesCard2: "<strong>2:</strong> Resets the pile. Can be played on anything. The next player can play any card.",
  rulesCard10: "<strong>10:</strong> Burns the pile. The pile is removed from the game, and you get another turn. Can be played on anything.",
  rulesCardFourOfAKind: "<strong>Four of a Kind:</strong> Four cards of the same value in a row also burn the pile and give you another turn.",
  rulesFinal: "Play from your hand, then your face-up cards, and finally your blind, face-down cards. (C) Johnny Heggelund",
  gameStarted: (playerName) => `The game has started. It's ${playerName}'s turn!`,
  playerTurn: (playerName) => `It's ${playerName}'s turn.`,
  pickedUpPile: (playerName) => `${playerName} picked up the pile.`,
  burnedPile: (playerName) => `${playerName} burned the pile and gets another turn.`,
  playedCard: (playerName, card) => `${playerName} played ${card}.`,
  playedMultiCards: (playerName, count, rank) => `${playerName} played ${count} cards of rank ${rank}.`,
  fourOfAKind: "Four of a kind! The pile is burned.",
  pileReset: "The pile has been reset.",
  invalidMove: "Invalid move! Play a higher card or pick up the pile.",
  playedBlindValid: (card) => `You played ${card} blindly... and it was a valid move!`,
  playedBlindInvalid: (card) => `You played ${card} blindly... Tough luck! You must pick up the pile.`,
  aiPlaysBlindly: (aiName) => `${aiName} is playing blindly...`,
  aiPlaysBlindSuccess: (aiName, card) => `${aiName} played ${card} and succeeded!`,
  aiPlaysBlindFail: (aiName, card) => `${aiName} played ${card} and had to pick up the pile!`,
  pickupTooltip: "Can't play. Click to pick up the pile.",
  cardCount: (count) => (count === 1 ? '1 card' : `${count} cards`),
  winTitle: 'üéâ YOU WON! üéâ',
  winText: (aiName) => `You got rid of all your cards. ${aiName} is the Shithead!`,
  lossTitle: 'üò≠ YOU LOST! üò≠',
  lossText: "The computer got rid of all its cards. You are the Shithead! Better luck next time.",
  playAgainButton: 'Play Again',
  renderError: 'An error occurred while rendering the game board:',
  criticalError: 'A critical error has occurred. Please reload the page.',
};
document.addEventListener('DOMContentLoaded', () => {
  const PLAYER_NAME = lang.playerName;
  const AI_NAME = lang.aiName;
  const INITIAL_HAND_CARDS = 3;
  const INITIAL_FACE_UP_CARDS = 3;
  const INITIAL_FACE_DOWN_CARDS = 3;
  const MIN_CARDS_IN_HAND = 3;
  const AI_TURN_DELAY = 1200;
  const BURN_PILE_DELAY = 600;
  const AI_EXTRA_TURN_DELAY = 1000;
  const AI_BURN_THRESHOLD = 5;
  const LOG_MESSAGE_LIMIT = 20;
  const CARD_RANKS = {
    '3': 1,
    '4': 2,
    '5': 3,
    '6': 4,
    '7': 5,
    '8': 6,
    '9': 7,
    'J': 8,
    'Q': 9,
    'K': 10,
    'A': 11,
    '2': 12,
    '10': 13
  };
  const gameTable = document.getElementById('game-table');
  const gameStatusOverlay = document.getElementById('game-status-overlay');
  const infoPanelHeader = document.getElementById('info-panel-header');
  const infoPanelBody = document.getElementById('info-panel-body');
  const startGameBtn = document.getElementById('start-game-btn');
  let gameState = {};
  const getCardValue = (card) => (card ? card.slice(0, -1) : '');
  const getCardRank = (card) => (card ? CARD_RANKS[getCardValue(card)] || 0 : 0);
  const sortCards = (cards) => cards.sort((a, b) => getCardRank(a) - getCardRank(b));
  const createNewGame = () => {
    const suits = ['H', 'D', 'C', 'S'];
    const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
    let deck = [];
    for (const suit of suits) {
      for (const value of values) {
        deck.push(value + suit);
      }
    }
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    gameState = {
      players: {
        [PLAYER_NAME]: {
          name: PLAYER_NAME,
          hand: sortCards(deck.splice(0, INITIAL_HAND_CARDS)),
          faceUp: sortCards(deck.splice(0, INITIAL_FACE_UP_CARDS)),
          faceDown: deck.splice(0, INITIAL_FACE_DOWN_CARDS),
        },
        [AI_NAME]: {
          name: AI_NAME,
          hand: sortCards(deck.splice(0, INITIAL_HAND_CARDS)),
          faceUp: sortCards(deck.splice(0, INITIAL_FACE_UP_CARDS)),
          faceDown: deck.splice(0, INITIAL_FACE_DOWN_CARDS),
        },
      },
      deck: deck,
      discardPile: [],
      log: [],
      turn: PLAYER_NAME,
      winner: null,
      gameInProgress: true,
    };
    addLogMessage(lang.gameStarted(PLAYER_NAME));
    renderGameBoard();
  };
  const processMove = (player, card, sourcePile) => {
    if (!gameState.gameInProgress) return;
    if (!removeCardFromSource(player, card, sourcePile)) return;
    gameState.discardPile.push(card);
    addLogMessage(lang.playedCard(gameState.players[player].name, card));
    renderGameBoard();
    if (checkWinCondition(player)) return;
    if (checkFourOfAKind()) {
      addLogMessage(lang.fourOfAKind);
      burnPile(player);
      return;
    }
    const cardValue = getCardValue(card);
    if (cardValue === '10') {
      burnPile(player);
      return;
    }
    if (cardValue === '2') {
      addLogMessage(lang.pileReset);
    }
    drawCards(player);
    if (checkWinCondition(player)) return;
    switchTurn();
  };
  const aiTurn = () => {
    if (gameState.turn !== AI_NAME || !gameState.gameInProgress) return;
    const ai = gameState.players[AI_NAME];
    const playableFrom =
      ai.hand.length > 0 ?
      'hand' :
      ai.faceUp.length > 0 ?
      'faceUp' :
      'faceDown';
    const cardOptions = ai[playableFrom];
    if (playableFrom === 'faceDown') {
      const cardToPlay = cardOptions[Math.floor(Math.random() * cardOptions.length)];
      addLogMessage(lang.aiPlaysBlindly(AI_NAME));
      setTimeout(() => {
        if (checkMoveLegality(cardToPlay)) {
          addLogMessage(lang.aiPlaysBlindSuccess(AI_NAME, cardToPlay));
          processMove(AI_NAME, cardToPlay, 'faceDown');
        } else {
          addLogMessage(lang.aiPlaysBlindFail(AI_NAME, cardToPlay));
          if (removeCardFromSource(AI_NAME, cardToPlay, 'faceDown')) {
            gameState.discardPile.push(cardToPlay);
          }
          renderGameBoard();
          setTimeout(() => playerPicksUpPile(AI_NAME), 500);
        }
      }, 500);
      return;
    }
    const legalMoves = cardOptions.filter(checkMoveLegality);
    if (legalMoves.length === 0) {
      playerPicksUpPile(AI_NAME);
      return;
    }
    const tens = legalMoves.filter((c) => getCardValue(c) === '10');
    if (tens.length > 0 && gameState.discardPile.length >= AI_BURN_THRESHOLD) {
      processMove(AI_NAME, tens[0], playableFrom);
      return;
    }
    const valueCounts = {};
    for (const card of cardOptions) {
      const value = getCardValue(card);
      valueCounts[value] = (valueCounts[value] || 0) + 1;
    }
    const twos = legalMoves.filter((c) => getCardValue(c) === '2');
    const normalMoves = legalMoves.filter(
      (c) => !['2', '10'].includes(getCardValue(c))
    );
    if (normalMoves.length > 0) {
      let cardToPlay = null;
      for (const card of normalMoves) {
        if (valueCounts[getCardValue(card)] === 1) {
          cardToPlay = card;
          break;
        }
      }
      if (!cardToPlay) {
        cardToPlay = normalMoves[0];
      }
      processMove(AI_NAME, cardToPlay, playableFrom);
      return;
    }
    if (twos.length > 0) {
      processMove(AI_NAME, twos[0], playableFrom);
      return;
    }
    if (tens.length > 0) {
      processMove(AI_NAME, tens[0], playableFrom);
      return;
    }
    if (legalMoves.length > 0) {
      processMove(AI_NAME, legalMoves[0], playableFrom);
    }
  };
  const switchTurn = () => {
    if (gameState.winner) return;
    gameState.turn = gameState.turn === PLAYER_NAME ? AI_NAME : PLAYER_NAME;
    addLogMessage(lang.playerTurn(gameState.players[gameState.turn].name));
    if (gameState.turn === AI_NAME) {
      setTimeout(aiTurn, AI_TURN_DELAY);
    } else {
      renderGameBoard();
    }
  };
  const playerPicksUpPile = (player) => {
    if (gameState.discardPile.length === 0) {
      switchTurn();
      return;
    }
    const p = gameState.players[player];
    p.hand.push(...gameState.discardPile);
    sortCards(p.hand);
    gameState.discardPile = [];
    addLogMessage(lang.pickedUpPile(p.name));
    switchTurn();
  };
  const burnPile = (player) => {
    setTimeout(() => {
      gameState.discardPile = [];
      addLogMessage(lang.burnedPile(gameState.players[player].name));
      drawCards(player);
      renderGameBoard();
      if (checkWinCondition(player)) return;
      if (player === AI_NAME) {
        setTimeout(aiTurn, AI_EXTRA_TURN_DELAY);
      }
    }, BURN_PILE_DELAY);
  };
  const drawCards = (player) => {
    const p = gameState.players[player];
    while (
      p.hand.length < MIN_CARDS_IN_HAND &&
      gameState.deck.length > 0
    ) {
      p.hand.push(gameState.deck.pop());
    }
    sortCards(p.hand);
  };
  const checkMoveLegality = (cardToPlay) => {
    const cardValue = getCardValue(cardToPlay);
    if (cardValue === '2' || cardValue === '10') return true;
    if (gameState.discardPile.length > 0) {
      const topCard = gameState.discardPile[gameState.discardPile.length - 1];
      if (getCardValue(topCard) === '2') {
        return true;
      }
    }
    const effectiveTopCard = getEffectiveTopCard();
    if (!effectiveTopCard) return true;
    return getCardRank(cardToPlay) >= getCardRank(effectiveTopCard);
  };
  const getEffectiveTopCard = () => {
    if (gameState.discardPile.length === 0) return null;
    for (let i = gameState.discardPile.length - 1; i >= 0; i--) {
      if (getCardValue(gameState.discardPile[i]) !== '2') {
        return gameState.discardPile[i];
      }
    }
    return null;
  };
  const checkFourOfAKind = () => {
    if (gameState.discardPile.length < 4) return false;
    const topFour = gameState.discardPile.slice(-4);
    const firstValue = getCardValue(topFour[0]);
    return topFour.every(card => getCardValue(card) === firstValue);
  };
  const checkWinCondition = (player) => {
    const p = gameState.players[player];
    if (
      p.hand.length === 0 &&
      p.faceUp.length === 0 &&
      p.faceDown.length === 0
    ) {
      gameState.winner = player;
      gameState.gameInProgress = false;
      setTimeout(() => showEndScreen(player === PLAYER_NAME), 600);
      return true;
    }
    return false;
  };
  const removeCardFromSource = (player, card, sourcePile) => {
    const source = gameState.players[player][sourcePile];
    const index = source.indexOf(card);
    if (index > -1) {
      source.splice(index, 1);
      return true;
    }
    console.error(`CRITICAL ERROR: Card ${card} not found in ${player}'s ${sourcePile}.`);
    return false;
  };
  const addLogMessage = (message) => {
    gameState.log.push(message);
    if (gameState.log.length > LOG_MESSAGE_LIMIT * 2) {
      gameState.log = gameState.log.slice(-LOG_MESSAGE_LIMIT);
    }
    if (gameState.gameInProgress) {
      updateLog();
    }
  };
  const executeMultiPlay = (player, cards, sourcePile) => {
    if (!gameState.gameInProgress) return;
    const p = gameState.players[player];
    const source = p[sourcePile];
    for (const card of cards) {
      const index = source.indexOf(card);
      if (index > -1) {
        source.splice(index, 1);
      } else {
        console.error(`Error: Card ${card} not found for multi-play in ${player}'s ${sourcePile}.`);
        return;
      }
    }
    gameState.discardPile.push(...cards);
    addLogMessage(lang.playedMultiCards(p.name, cards.length, getCardValue(cards[0])));
    renderGameBoard();
    if (checkWinCondition(player)) return;
    if (checkFourOfAKind()) {
      addLogMessage(lang.fourOfAKind);
      burnPile(player);
      return;
    }
    if (sourcePile === 'hand') {
      drawCards(player);
    }
    if (checkWinCondition(player)) return;
    switchTurn();
  };
  const handlePlayerMove = (card, sourcePile) => {
    if (gameState.turn !== PLAYER_NAME || !gameState.gameInProgress) return;
    if (sourcePile === 'faceDown') {
      if (checkMoveLegality(card)) {
        addLogMessage(lang.playedBlindValid(card));
        processMove(PLAYER_NAME, card, 'faceDown');
      } else {
        addLogMessage(lang.playedBlindInvalid(card));
        if (removeCardFromSource(PLAYER_NAME, card, 'faceDown')) {
          gameState.discardPile.push(card);
        }
        renderGameBoard();
        setTimeout(() => playerPicksUpPile(PLAYER_NAME), 800);
      }
      return;
    }
    if (!checkMoveLegality(card)) {
      addLogMessage(lang.invalidMove);
      return;
    }
    const player = gameState.players[PLAYER_NAME];
    const playerSource = player[sourcePile];
    const cardValue = getCardValue(card);
    if (cardValue === '2' || cardValue === '10') {
      processMove(PLAYER_NAME, card, sourcePile);
      return;
    }
    const sameValueCards = playerSource.filter(c => getCardValue(c) === cardValue);
    let existingCount = 0;
    const tempPile = [...gameState.discardPile].reverse();
    for (const c of tempPile) {
      if (getCardValue(c) === cardValue) {
        existingCount++;
      } else {
        break;
      }
    }
    const cardsToPlayCount = sameValueCards.length;
    const totalCountAfterPlay = existingCount + cardsToPlayCount;
    if (totalCountAfterPlay >= 4) {
      executeMultiPlay(PLAYER_NAME, sameValueCards, sourcePile);
      return;
    }
    processMove(PLAYER_NAME, card, sourcePile);
  };
  const initializeUI = () => {
    document.title = lang.gameTitle;
    gameStatusOverlay.querySelector('h1').textContent = lang.gameTitle;
    startGameBtn.textContent = lang.playButton;
    infoPanelHeader.textContent = lang.rulesTitle;
    infoPanelBody.innerHTML = `
<p>${lang.rulesGoal}</p><br/>
<p>${lang.rulesGameplay}</p><br/>
<p>${lang.rulesCardOrder}</p><br/>
<p>${lang.rulesSpecialCards}</p>
<ul style="padding-left: 20px; margin-top: 0px">
<li>${lang.rulesCard2}</li><br/>
<li>${lang.rulesCard10}</li><br/>
<li>${lang.rulesCardFourOfAKind}</li>
</ul><br/>
<p>${lang.rulesFinal}</p>
`;
    gameStatusOverlay.querySelector('.status-text').textContent = '';
  };
  const updateLog = () => {
    infoPanelHeader.textContent = lang.logTitle;
    infoPanelBody.innerHTML = '';
    const logToShow = gameState.log.slice(-LOG_MESSAGE_LIMIT).reverse();
    logToShow.forEach((msg) => {
      const p = document.createElement('p');
      p.textContent = `> ${msg}`;
      infoPanelBody.appendChild(p);
    });
    infoPanelBody.scrollTop = 0;
  };
  const showEndScreen = (playerWon) => {
    const title = gameStatusOverlay.querySelector('h1');
    const text = gameStatusOverlay.querySelector('.status-text');
    const button = gameStatusOverlay.querySelector('button');
    title.textContent = playerWon ? lang.winTitle : lang.lossTitle;
    text.textContent = playerWon ? lang.winText(AI_NAME) : lang.lossText;
    button.textContent = lang.playAgainButton;
    gameStatusOverlay.style.display = 'flex';
  };
  const renderCard = (cardString, isFaceUp = true, isFaceDownOnTable = false) => {
    const card = document.createElement('div');
    card.className = 'card';
    if (!isFaceUp) {
      card.classList.add('face-down');
      card.dataset.card = cardString;
      return card;
    }
    const value = getCardValue(cardString);
    const suitChar = cardString.slice(-1);
    const suitSymbols = {
      H: '‚ô•',
      D: '‚ô¶',
      C: '‚ô£',
      S: '‚ô†'
    };
    card.innerHTML = `<div class="card-value">${value}</div><div class="card-suit">${suitSymbols[suitChar]}</div>`;
    card.dataset.card = cardString;
    card.style.color = ['H', 'D'].includes(suitChar) ? 'var(--red-color)' : '#333';
    if (isFaceDownOnTable) card.classList.add('face-up');
    return card;
  };
  const updateHandScrollButtons = () => {
    const playerHand = document.getElementById('player-hand');
    if (!playerHand) return;
    const scrollLeftBtn = document.getElementById('scroll-left');
    const scrollRightBtn = document.getElementById('scroll-right');
    const hasOverflow = playerHand.scrollWidth > playerHand.clientWidth;
    if (!hasOverflow) {
      scrollLeftBtn.style.display = 'none';
      scrollRightBtn.style.display = 'none';
      return;
    }
    scrollLeftBtn.style.display = 'block';
    scrollRightBtn.style.display = 'block';
    scrollLeftBtn.disabled = playerHand.scrollLeft < 1;
    scrollRightBtn.disabled = playerHand.scrollLeft + playerHand.clientWidth >= playerHand.scrollWidth - 1;
  }
  const renderGameBoard = () => {
    try {
      if (!gameState || !gameState.players) return;
      gameTable.innerHTML = '';
      const {
        players,
        deck,
        discardPile,
        turn
      } = gameState;
      const aiArea = document.createElement('div');
      aiArea.className = 'player-area opponent-area';
      aiArea.innerHTML = `<div class="player-info ${turn === AI_NAME ? 'active-turn' : ''}">${AI_NAME} (${lang.cardCount(players[AI_NAME].hand.length)})</div>`;
      const aiTableCards = document.createElement('div');
      aiTableCards.className = 'table-cards';
      players[AI_NAME].faceDown.forEach((cardStr, i) => {
        const pile = document.createElement('div');
        pile.className = 'table-card-pile';
        pile.appendChild(renderCard(cardStr, false));
        if (players[AI_NAME].faceUp[i]) {
          pile.appendChild(renderCard(players[AI_NAME].faceUp[i], true, true));
        }
        aiTableCards.appendChild(pile);
      });
      aiArea.appendChild(aiTableCards);
      gameTable.appendChild(aiArea);
      const playArea = document.createElement('div');
      playArea.id = 'play-area';
      const deckPile = document.createElement('div');
      deckPile.className = 'card-pile';
      if (deck.length > 0) {
        deckPile.appendChild(renderCard(null, false));
        deckPile.innerHTML += `<div id="deck-pile-count">${deck.length}</div>`;
      }
      const discardPileDiv = document.createElement('div');
      discardPileDiv.id = 'discard-pile';
      discardPileDiv.className = 'card-pile';
      if (discardPile.length > 0) {
        discardPileDiv.appendChild(renderCard(discardPile[discardPile.length - 1]));
      } else {
        discardPileDiv.textContent = lang.pileLabel;
      }
      if (turn === PLAYER_NAME) {
        const p = players[PLAYER_NAME];
        const currentPlayableCards = p.hand.length > 0 ? p.hand : p.faceUp;
        let canPlay = currentPlayableCards.some(checkMoveLegality);
        if (p.hand.length === 0 && p.faceUp.length === 0) {
          canPlay = true;
        }
        if (!canPlay && discardPile.length > 0) {
          discardPileDiv.classList.add('pickup-enabled');
          discardPileDiv.title = lang.pickupTooltip;
          discardPileDiv.onclick = () => playerPicksUpPile(PLAYER_NAME);
        }
      }
      playArea.appendChild(deckPile);
      playArea.appendChild(discardPileDiv);
      gameTable.appendChild(playArea);
      const playerArea = document.createElement('div');
      playerArea.className = 'player-area your-area';
      playerArea.innerHTML = `<div class="player-info ${turn === PLAYER_NAME ? 'active-turn' : ''}">${PLAYER_NAME} (${lang.cardCount(players[PLAYER_NAME].hand.length)})</div>`;
      const handContainer = document.createElement('div');
      handContainer.className = 'hand-container';
      const playerHand = document.createElement('div');
      playerHand.id = 'player-hand';
      const playerTableCards = document.createElement('div');
      playerTableCards.className = 'cards-area table-cards';
      const canPlayFromHand = players[PLAYER_NAME].hand.length > 0;
      const canPlayFromFaceUp = !canPlayFromHand && players[PLAYER_NAME].faceUp.length > 0;
      const canPlayFromFaceDown = !canPlayFromHand && !canPlayFromFaceUp && players[PLAYER_NAME].faceDown.length > 0;
      players[PLAYER_NAME].hand.forEach((cardStr) => {
        const cardEl = renderCard(cardStr);
        if (turn === PLAYER_NAME && (canPlayFromHand || canPlayFromFaceUp)) {
          cardEl.onclick = () => handlePlayerMove(cardEl.dataset.card, 'hand');
        }
        playerHand.appendChild(cardEl);
      });
      players[PLAYER_NAME].faceDown.forEach((cardStr, i) => {
        const pile = document.createElement('div');
        pile.className = 'table-card-pile';
        const faceDownCardEl = renderCard(cardStr, false);
        pile.appendChild(faceDownCardEl);
        if (players[PLAYER_NAME].faceUp[i]) {
          const faceUpCardEl = renderCard(players[PLAYER_NAME].faceUp[i], true, true);
          pile.appendChild(faceUpCardEl);
          if (turn === PLAYER_NAME && canPlayFromFaceUp) {
            faceUpCardEl.style.cursor = 'pointer';
            faceUpCardEl.onclick = () => handlePlayerMove(faceUpCardEl.dataset.card, 'faceUp');
          }
        }
        if (turn === PLAYER_NAME && canPlayFromFaceDown) {
          faceDownCardEl.style.cursor = 'pointer';
          faceDownCardEl.onclick = () => handlePlayerMove(faceDownCardEl.dataset.card, 'faceDown');
        }
        playerTableCards.appendChild(pile);
      });
      handContainer.appendChild(playerHand);
      const scrollLeftBtn = document.createElement('button');
      scrollLeftBtn.id = 'scroll-left';
      scrollLeftBtn.className = 'scroll-button';
      scrollLeftBtn.textContent = '‚Üê';
      handContainer.appendChild(scrollLeftBtn);
      const scrollRightBtn = document.createElement('button');
      scrollRightBtn.id = 'scroll-right';
      scrollRightBtn.className = 'scroll-button';
      scrollRightBtn.textContent = '‚Üí';
      handContainer.appendChild(scrollRightBtn);
      playerArea.appendChild(handContainer);
      playerArea.appendChild(playerTableCards);
      gameTable.appendChild(playerArea);
      updateLog();
      setTimeout(updateHandScrollButtons, 50);
    } catch (e) {
      console.error(lang.renderError, e);
      gameTable.innerHTML = `<h1>${lang.criticalError}</h1><p>${e.message}</p>`;
    }
  };
  const startGame = () => {
    gameStatusOverlay.style.display = 'none';
    infoPanelHeader.textContent = lang.logTitle;
    createNewGame();
  };
  startGameBtn.addEventListener('click', startGame);
  gameTable.addEventListener('click', (e) => {
    const playerHand = document.getElementById('player-hand');
    if (!playerHand || !e.target.matches('.scroll-button')) return;
    const scrollAmount = playerHand.clientWidth * 0.8;
    if (e.target.id === 'scroll-left') {
      playerHand.scrollBy({
        left: -scrollAmount,
        behavior: 'smooth'
      });
    } else if (e.target.id === 'scroll-right') {
      playerHand.scrollBy({
        left: scrollAmount,
        behavior: 'smooth'
      });
    }
    setTimeout(updateHandScrollButtons, 350);
  });
  initializeUI();
});

</script>
  </body>
</html>