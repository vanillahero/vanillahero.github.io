<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adventure</title>
<style>

@font-face {
  font-family: 'GameEmoji';
  src: url('data:font/woff2;charset=utf-8;base64,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') format('woff2');
  font-weight: normal;
  font-style: normal;
  unicode-range: U+0080-10FFFF;
}

body,
html {
  margin: 0;
  padding: 0;
  overflow: hidden;
  font-family: 'GameEmoji', 'Segoe UI Emoji', sans-serif;
  background-color: #1a1a1a;
  display: flex;
  flex-direction: column;
  height: 100vh;
}

#game-container {
  flex-grow: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  height: auto;
  background-color: #245E28;
  position: relative;
  overflow: hidden;
  transition: background-color 2s ease-in-out;
}

#game-world {
  position: absolute;
  width: 100%;
  height: 100%;
}

#night-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #000033;
  opacity: 0;
  z-index: 2;
  pointer-events: none;
  transition: opacity 5s ease-in-out;
  mask-image: radial-gradient(circle 12vmin at center, transparent 0%, black 100%);
  -webkit-mask-image: radial-gradient(circle 12vmin at center, transparent 0%, black 100%);
}

#night-overlay.is-night {
  opacity: 0.85;
}

#rain-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 3;
  pointer-events: none;
  overflow: hidden;
}

.raindrop {
  position: absolute;
  width: 2px;
  height: 12px;
  background-color: rgba(173, 216, 230, 0.6);
  border-radius: 1px;
  animation: fall linear infinite;
  transform-origin: bottom;
  will-change: transform;
}

@keyframes fall {
  from {
    transform: translateY(-20vh) translateX(-5vw) rotate(20deg);
  }

  to {
    transform: translateY(120vh) translateX(-15vw) rotate(20deg);
  }
}

#lightning-flash {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #ffffff;
  opacity: 0;
  z-index: 4;
  pointer-events: none;
  transition: opacity 0.5s ease-out;
}

#map-grid {
  position: absolute;
  transform-origin: top left;
}

.cell {
  position: absolute;
  width: 8vmin;
  height: 8vmin;
  font-size: 6.5vmin;
  display: flex;
  justify-content: center;
  align-items: center;
  user-select: none;
  line-height: 1;
}

@keyframes shake {

  0%,
  100% {
    transform: translate(0, 0) rotate(0);
  }

  25% {
    transform: translate(-3px, 0) rotate(-1deg);
  }

  50% {
    transform: translate(3px, 0) rotate(1deg);
  }

  75% {
    transform: translate(-3px, 0) rotate(-1deg);
  }
}

.shaking {
  animation: shake 0.15s linear;
}

@keyframes pulse {

  0%,
  100% {
    transform: scale(1);
  }

  50% {
    transform: scale(1.1);
  }
}

@keyframes pulse-red {

  0%,
  100% {
    transform: scale(1);
    color: #ffcdd2;
    background-color: rgba(239, 83, 80, 0.7);
  }

  50% {
    transform: scale(1.05);
    color: #ffffff;
    background-color: rgba(244, 67, 54, 0.9);
  }
}

.hud-item.low-health-warning {
  animation: pulse-red 1s infinite ease-in-out;
  border-radius: 8px;
}

.cell.path {
  background-color: rgba(224, 224, 224, 0.3);
}

.cell.underworld-path {
  background-color: #4a4a4a;
}

.cell.shelter {
  font-size: 7vmin;
}

.cell.large {
  font-size: 8vmin;
}

.cell.medium {
  font-size: 7vmin;
}

.cell.small {
  font-size: 2.5vmin;
  display: flex;
  align-items: flex-end;
  padding-bottom: 5px;
}

#player,
.monster-container,
.npc-container {
  position: absolute;
  width: 8vmin;
  height: 8vmin;
  z-index: 5;
  will-change: transform;
  transform-origin: center center;
  text-shadow:
    -1px 0 0 #000,
    1px 0 0 #000,
    0 -1px 0 #000,
    0 1px 0 #000;
}

.player-sprite,
.monster-sprite,
.npc-sprite {
  width: 100%;
  height: 100%;
  font-size: 6.5vmin;
  display: flex;
  justify-content: center;
  align-items: center;
  transform-origin: center center;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  background-color: transparent;
}

.fighting-monster .monster-sprite {
  cursor: crosshair;
  animation: pulse 1s infinite;
}

@keyframes walk-bob {

  0%,
  100% {
    transform: translateY(0);
  }

  50% {
    transform: translateY(-8%);
  }
}

#player.is-walking .player-sprite {
  animation: walk-bob 0.4s infinite ease-in-out;
}

#player-floating-text-container {
  position: absolute;
  top: -85px;
  left: 50%;
  transform: translateX(-50%);
  width: 250px;
  display: flex;
  flex-direction: column-reverse;
  align-items: center;
  z-index: 10;
  pointer-events: none;
}

.floating-text {
  background: rgba(26, 26, 26, 0.85);
  color: #f0f0f0;
  padding: 5px 12px;
  border-radius: 12px;
  font-size: 1.8vmin;
  font-weight: bold;
  text-align: center;
  margin-bottom: 5px;
  white-space: nowrap;
  animation: fade-out-up 3s ease-out forwards;
}

@keyframes fade-out-up {
  0% {
    opacity: 1;
    transform: translateY(0);
  }

  80% {
    opacity: 1;
    transform: translateY(0);
  }

  100% {
    opacity: 0;
    transform: translateY(-20px);
  }
}

.arrow {
  position: absolute;
  font-size: 4vmin;
  z-index: 6;
  pointer-events: none;
  color: #5d4037;
  will-change: transform, left, top;
}

#hud {
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  width: auto;
  min-width: 80vw;
  background: #512DA8;
  background-image: linear-gradient(to bottom, #7E57C2, #512DA8);
  border: 4px solid #311B92;
  color: #EDE7F6;
  display: flex;
  justify-content: flex-start;
  align-items: center;
  padding: 5px;
  font-size: 2.2vmin;
  font-weight: bold;
  z-index: 10;
  border-radius: 12px;
  overflow-x: auto;
  gap: 0.5rem;
}

.hud-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 0 8px;
  white-space: nowrap;
}

.hud-label {
  font-size: 1.8vmin;
  opacity: 0.8;
}

.hud-value {
  font-size: 3vmin;
}

#key-display,
#time-display {
  font-size: 3.5vmin;
}

#weapon-bar {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 5px;
  border: 2px solid #311B92;
  border-radius: 8px;
  padding: 2px 5px;
  background: rgba(0, 0, 0, 0.2);
}

.weapon-slot {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 2px 4px;
  border-radius: 4px;
  transition: background-color 0.2s, transform 0.2s;
}

.weapon-slot.active {
  background-color: rgba(255, 255, 255, 0.3);
  transform: scale(1.1);
}

.weapon-key {
  font-size: 1.5vmin;
  font-weight: bold;
  color: #fff;
}

.weapon-emoji {
  font-size: 3.5vmin;
}

.game-button {
  position: absolute;
  z-index: 15;
  padding: 10px 15px;
  font-size: 2vmin;
  font-weight: bold;
  background: #512DA8;
  border: 3px solid #311B92;
  color: #EDE7F6;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.1s ease, background-color 0.2s;
}

.game-button:hover {
  transform: scale(1.05);
  background-color: #7E57C2;
}

.game-button.top-left {
  top: 15px;
  left: 15px;
}

.game-button.top-right {
  top: 15px;
  right: 15px;
}

.health-bar-container {
  position: absolute;
  bottom: -15px;
  left: 5%;
  width: 90%;
  height: 10px;
  background-color: #333;
  border: 1px solid #111;
  border-radius: 5px;
  overflow: hidden;
  z-index: 6;
}

#player .health-bar-container {
  top: -50px;
  bottom: auto;
}

.health-bar-inner {
  height: 100%;
  width: 100%;
  border-radius: 4px;
  transition: width 0.3s ease-out;
}

.health-bar-inner.player {
  background-color: #4caf50;
}

.health-bar-inner.monster {
  background-color: #f44336;
}

#player .status-bar-container {
  position: absolute;
  top: -50px;
  left: 10%;
  width: 80%;
  height: 8px;
  background-color: rgba(20, 20, 20, 0.7);
  border: 1px solid #111;
  border-radius: 4px;
  z-index: 6;
  opacity: 1;
  transition: opacity 0.5s ease-in-out;
}

#player .status-bar-container.fading-out {
  opacity: 0;
}

#player .status-bar-inner {
  height: 100%;
  width: 100%;
  background-color: #4caf50;
  transition: width 0.3s ease-out;
}

#message-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 20;
}

#message-box {
  background: #2a2135;
  color: #f0f0f0;
  border: 4px solid #311B92;
  padding: 15px 20px;
  border-radius: 10px;
  width: 80vw;
  max-width: 1200px;
  max-height: 85vh;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
}

#message-text {
  font-size: 2.2vmin;
  margin-bottom: 25px;
  text-align: left;
  flex-grow: 1;
}

#message-text h2.how-to-play-title,
#message-text h3 {
  text-align: center;
  color: #7E57C2;
  margin: 0;
}

.how-to-play-columns {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  gap: 2.5rem;
  align-items: flex-start;
  width: 100%;
}

.how-to-play-column {
  flex: 1;
  min-width: 280px;
}

.how-to-play-column h3 {
  margin-top: 0;
  margin-bottom: 10px;
}

.how-to-play-column ul {
  padding-left: 20px;
  margin: 0;
  list-style-position: outside;
}

.how-to-play-column li {
  margin-bottom: 6px;
}

.how-to-play-column li::marker {
  color: #7E57C2;
}

.how-to-play-final-message {
  text-align: center;
  margin-top: 25px;
  width: 100%;
}

#message-options {
  display: flex;
  justify-content: center;
  gap: 5px;
  margin-top: 0;
  flex-shrink: 0;
}

.message-option-button {
  padding: 10px 20px;
  border: 2px solid #311B92;
  background-color: #512DA8;
  color: #EDE7F6;
  font-size: 2vmin;
  font-weight: bold;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.message-option-button:hover {
  background-color: #7E57C2;
}

#message-box.has-options #message-button {
  display: none;
}

#message-button {
  padding: 12px 24px;
  border: 2px solid #311B92;
  background-color: #512DA8;
  color: #EDE7F6;
  font-size: 2.5vmin;
  font-weight: bold;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.2s;
  margin: 0 auto;
  flex-shrink: 0;
}

#message-button:hover {
  background-color: #7E57C2;
}

.hidden {
  display: none !important;
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #2a2135;
}

::-webkit-scrollbar-thumb {
  background: #512DA8;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #7E57C2;
}

* {
  scrollbar-width: thin;
  scrollbar-color: #512DA8 #2a2135;
}

</style>
  </head>
  <body>
    <div id="game-container">
      <div id="rain-container"></div>
      <div id="lightning-flash"></div>
      <button id="how-to-play-button" class="game-button top-left"></button>
      <div style="position: absolute; top: 15px; right: 15px; z-index: 15; display: flex; flex-direction: column; gap: 10px;">
        <button id="save-game-button" class="game-button" style="position: static;" title="Quick Save (Local)"></button>
        <button id="export-btn" class="game-button" style="position: static;" title="Export Save"></button>
        <button id="import-btn" class="game-button" style="position: static;" title="Import Save"></button>
      </div>
      <input type="file" id="import-input" accept=".json" style="display: none;">
      <div id="hud">
        <div class="hud-item">
          <span class="hud-label">Level</span>
          <span id="level-display" class="hud-value">1</span>
        </div>
        <div class="hud-item" id="hud-hp">
          <span class="hud-label"> Health</span>
          <span id="hp-display" class="hud-value">100/100</span>
        </div>
        <div class="hud-item" id="hud-strength">
          <span class="hud-label"> Strength</span>
          <span id="strength-display" class="hud-value">5</span>
        </div>
        <div class="hud-item" id="hud-weapon">
          <span class="hud-label">Weapon</span>
          <div id="weapon-bar"></div>
        </div>
        <div class="hud-item" id="hud-xp">
          <span class="hud-label"> XP</span>
          <span id="xp-display" class="hud-value">0/20</span>
        </div>
        <div class="hud-item">
          <span class="hud-label"> Wood</span>
          <span id="wood-display" class="hud-value">0</span>
        </div>
        <div class="hud-item">
          <span class="hud-label"> Stone</span>
          <span id="stone-display" class="hud-value">0</span>
        </div>
        <div class="hud-item">
          <span class="hud-label"> Gem</span>
          <span id="gem-display" class="hud-value">0</span>
        </div>
        <div class="hud-item">
          <span class="hud-label"> Herb</span>
          <span id="herb-display" class="hud-value">0</span>
        </div>
        <div class="hud-item">
          <span class="hud-label"> Arrows</span>
          <span id="arrows-display" class="hud-value">0</span>
        </div>
        <div class="hud-item">
          <span class="hud-label"> Key</span>
          <span id="key-display" class="hud-value"></span>
        </div>
        <div class="hud-item">
          <span id="time-display" class="hud-value"> Day</span>
        </div>
      </div>
      <div id="game-world" oncontextmenu="return false;">
        <div id="player">
          <div id="player-floating-text-container"></div>
          <div class="player-sprite"></div>
        </div>
      </div>
      <div id="night-overlay"></div>
    </div>
    <div id="message-overlay" class="hidden">
      <div id="message-box">
        <div id="message-text"></div>
        <div id="message-options"></div>
        <button id="message-button">OK</button>
      </div>
    </div>
<script>

const audioManager = {
  context: null,
  isInitialized: false,
  mainGain: null,
  activeAmbiance: {},
  birdChirpTimer: null,
  owlHootTimer: null,
  soundCooldowns: {},

  init: function() {
    if (this.isInitialized) return;
    try {
      this.context = new(window.AudioContext || window.webkitAudioContext)();
      this.mainGain = this.context.createGain();
      this.mainGain.connect(this.context.destination);
      this.mainGain.gain.setValueAtTime(1.0, this.context.currentTime);
      this.isInitialized = true;
      console.log("Audio Context initialized.");
    } catch (e) {
      console.error("Web Audio API not supported in this browser.", e);
    }
  },

  sounds: {
    'tree_chop': (ctx, dest) => {
      const bufferSize = ctx.sampleRate * 0.1;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(1000, ctx.currentTime);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.3, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
      noise.connect(filter).connect(gain).connect(dest);
      noise.start(ctx.currentTime);
      noise.stop(ctx.currentTime + 0.1);
    },

    'item_pickup': (ctx, dest) => {
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(600, ctx.currentTime);
      osc.frequency.linearRampToValueAtTime(1200, ctx.currentTime + 0.1);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.2, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
      osc.connect(gain).connect(dest);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.1);
    },

    'wind_ambiance': (ctx, dest) => {
      const t = ctx.currentTime;
      const bufferSize = 5 * ctx.sampleRate;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const output = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        output[i] = (Math.random() * 2 - 1) * 0.3;
      }
      const fadeLength = Math.floor(ctx.sampleRate * 0.01);
      for (let i = 0; i < fadeLength; i++) {
        output[i] *= (i / fadeLength);
        output[bufferSize - 1 - i] *= (i / fadeLength);
      }
      const noiseNode = ctx.createBufferSource();
      noiseNode.buffer = buffer;
      noiseNode.loop = true;
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(300, t);
      filter.Q.setValueAtTime(1, t);
      const lfoFilterSlow = ctx.createOscillator();
      lfoFilterSlow.type = 'sine';
      lfoFilterSlow.frequency.setValueAtTime(0.08, t);
      const lfoFilterSlowGain = ctx.createGain();
      lfoFilterSlowGain.gain.setValueAtTime(100, t);
      lfoFilterSlow.connect(lfoFilterSlowGain).connect(filter.frequency);
      const lfoFilterFast = ctx.createOscillator();
      lfoFilterFast.type = 'sine';
      lfoFilterFast.frequency.setValueAtTime(0.3, t);
      const lfoFilterFastGain = ctx.createGain();
      lfoFilterFastGain.gain.setValueAtTime(50, t);
      lfoFilterFast.connect(lfoFilterFastGain).connect(filter.frequency);
      const masterGain = ctx.createGain();
      masterGain.gain.setValueAtTime(0.8, t);
      const lfoVolume = ctx.createOscillator();
      lfoVolume.type = 'sine';
      lfoVolume.frequency.setValueAtTime(0.11, t);
      const lfoVolumeGain = ctx.createGain();
      lfoVolumeGain.gain.setValueAtTime(0.2, t);
      lfoVolume.connect(lfoVolumeGain).connect(masterGain.gain);
      noiseNode.connect(filter).connect(masterGain).connect(dest);
      lfoFilterSlow.start(t);
      lfoFilterFast.start(t);
      lfoVolume.start(t);
      noiseNode.start(t);
      return {
        lfo: lfoFilterSlow,
        lfoFilterSlow,
        lfoFilterFast,
        lfoVolume,
        noiseNode
      };
    },

    'bird_chirp_1': (ctx, dest) => {
      const t = ctx.currentTime;
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.08, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
      gain.connect(dest);
      const osc1 = ctx.createOscillator();
      osc1.type = 'triangle';
      osc1.frequency.setValueAtTime(3500, t);
      osc1.frequency.linearRampToValueAtTime(2800, t + 0.08);
      const osc2 = ctx.createOscillator();
      osc2.type = 'sine';
      osc2.frequency.setValueAtTime(3520, t);
      osc2.frequency.linearRampToValueAtTime(2820, t + 0.08);
      osc1.connect(gain);
      osc2.connect(gain);
      osc1.start(t);
      osc2.start(t);
      osc1.stop(t + 0.08);
      osc2.stop(t + 0.08);
    },

    'bird_chirp_2': (ctx, dest) => {
      const t = ctx.currentTime;
      const osc = ctx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(3000, t);
      osc.frequency.linearRampToValueAtTime(3800, t + 0.04);
      osc.frequency.linearRampToValueAtTime(3200, t + 0.08);
      osc.frequency.linearRampToValueAtTime(3900, t + 0.12);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.07, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.42);
      osc.connect(gain).connect(dest);
      osc.start(t);
      osc.stop(t + 0.12);
    },

    'bird_chirp_3': (ctx, dest) => {
      const t = ctx.currentTime;
      const totalDuration = 0.5;
      const osc = ctx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(4000, t);
      osc.frequency.linearRampToValueAtTime(3500, t + totalDuration);
      const lfo = ctx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.setValueAtTime(30, t);
      lfo.frequency.linearRampToValueAtTime(20, t + totalDuration);
      const lfoGain = ctx.createGain();
      lfoGain.gain.setValueAtTime(100, t);
      lfo.connect(lfoGain).connect(osc.frequency);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.06, t + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.001, t + totalDuration);
      osc.connect(gain).connect(dest);
      lfo.start(t);
      osc.start(t);
      lfo.stop(t + totalDuration);
      osc.stop(t + totalDuration);
    },

    'player_attack_unarmed': (ctx, dest) => {
      const t = ctx.currentTime;
      const osc = ctx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(180, t);
      osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.4, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      osc.connect(gain).connect(dest);
      osc.start(t);
      osc.stop(t + 0.1);
    },

    'player_attack_sword': (ctx, dest) => {
      const t = ctx.currentTime;
      const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.15, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      const filter = ctx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(1500, t);
      filter.Q.setValueAtTime(10, t);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
      noise.connect(filter).connect(gain).connect(dest);
      noise.start(t);
      noise.stop(t + 0.15);
    },

    'player_attack_sledge': (ctx, dest) => {
      const t = ctx.currentTime;
      const osc = ctx.createOscillator();
      osc.type = 'square';
      osc.frequency.setValueAtTime(120, t);
      osc.frequency.exponentialRampToValueAtTime(80, t + 0.15);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.4, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
      osc.connect(gain).connect(dest);
      osc.start(t);
      osc.stop(t + 0.15);
    },

    'arrow_shoot_swoosh': (ctx, dest) => {
      const t = ctx.currentTime;
      const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      const filter = ctx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(3000, t);
      filter.Q.setValueAtTime(5, t);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
      noise.connect(filter).connect(gain).connect(dest);
      noise.start(t);
      noise.stop(t + 0.2);
    },

    'arrow_hit_thud': (ctx, dest) => {
      const t = ctx.currentTime;
      const osc = ctx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(150, t);
      osc.frequency.exponentialRampToValueAtTime(100, t + 0.08);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.5, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
      osc.connect(gain).connect(dest);
      osc.start(t);
      osc.stop(t + 0.08);
    },

    'monster_die_xp': (ctx, dest) => {
      const t = ctx.currentTime;
      const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource();
      noise.buffer = noiseBuffer;
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(1000, t);
      filter.frequency.exponentialRampToValueAtTime(200, t + 0.2);
      const noiseGain = ctx.createGain();
      noiseGain.gain.setValueAtTime(0.3, t);
      noiseGain.gain.linearRampToValueAtTime(0.001, t + 0.2);
      noise.connect(filter).connect(noiseGain).connect(dest);
      noise.start(t);
      noise.stop(t + 0.2);
      const osc = ctx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(800, t + 0.1);
      osc.frequency.linearRampToValueAtTime(1500, t + 0.2);
      const xpGain = ctx.createGain();
      xpGain.gain.setValueAtTime(0, t + 0.1);
      xpGain.gain.linearRampToValueAtTime(0.2, t + 0.11);
      xpGain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
      osc.connect(xpGain).connect(dest);
      osc.start(t + 0.1);
      osc.stop(t + 0.2);
    },

    'player_walk': (ctx, dest) => {
      const t = ctx.currentTime;
      const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.08, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(400, t);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.1, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
      noise.connect(filter).connect(gain).connect(dest);
      noise.start(t);
      noise.stop(t + 0.08);
    },

    'gather_stone': (ctx, dest) => {
      const t = ctx.currentTime;
      const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.05, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      const filter = ctx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.setValueAtTime(1500, t);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.3, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
      noise.connect(filter).connect(gain).connect(dest);
      noise.start(t);
      noise.stop(t + 0.05);
    },

    'gather_gem': (ctx, dest) => {
      const t = ctx.currentTime;
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(2000, t);
      osc.frequency.linearRampToValueAtTime(2500, t + 0.1);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.2, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      osc.connect(gain).connect(dest);
      osc.start(t);
      osc.stop(t + 0.1);
    },

    'gather_herb': (ctx, dest) => {
      const t = ctx.currentTime;
      const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      const filter = ctx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(2500, t);
      filter.Q.setValueAtTime(10, t);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.15, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      noise.connect(filter).connect(gain).connect(dest);
      noise.start(t);
      noise.stop(t + 0.1);
    },

    'night_ambiance': (ctx, dest) => {
      const bufferSize = 2 * ctx.sampleRate;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const output = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        output[i] = (Math.random() * 2 - 1) * 0.3;
        if (i > 0) output[i] = (output[i - 1] + (0.08 * output[i])) / 1.08;
      }
      const noiseNode = ctx.createBufferSource();
      noiseNode.buffer = buffer;
      noiseNode.loop = true;
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(200, ctx.currentTime);
      filter.Q.setValueAtTime(1, ctx.currentTime);
      const lfo = ctx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.setValueAtTime(0.05, ctx.currentTime);
      const lfoGain = ctx.createGain();
      lfoGain.gain.setValueAtTime(100, ctx.currentTime);
      lfo.connect(lfoGain).connect(filter.frequency);
      noiseNode.connect(filter).connect(dest);
      lfo.start(ctx.currentTime);
      noiseNode.start(ctx.currentTime);
      return {
        lfo,
        noiseNode
      };
    },

    'owl_hoot': (ctx, dest) => {
      const t = ctx.currentTime;
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(500, t);
      osc.frequency.linearRampToValueAtTime(400, t + 0.2);
      osc.frequency.setValueAtTime(450, t + 0.25);
      osc.frequency.linearRampToValueAtTime(350, t + 0.45);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.2, t + 0.05);
      gain.gain.setValueAtTime(0.2, t + 0.4);
      gain.gain.linearRampToValueAtTime(0, t + 0.45);
      osc.connect(gain).connect(dest);
      osc.start(t);
      osc.stop(t + 0.5);
    },

    'ghost_spawn': (ctx, dest) => {
      const t = ctx.currentTime;
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, t);
      osc.frequency.linearRampToValueAtTime(250, t + 1.0);
      const lfo = ctx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.setValueAtTime(5, t);
      const lfoGain = ctx.createGain();
      lfoGain.gain.setValueAtTime(10, t);
      lfo.connect(lfoGain).connect(osc.frequency);
      const buffer = ctx.createBuffer(1, ctx.sampleRate * 1.0, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      const filter = ctx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(800, t);
      filter.Q.setValueAtTime(5, t);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.2, t + 0.3);
      gain.gain.setValueAtTime(0.2, t + 0.7);
      gain.gain.linearRampToValueAtTime(0, t + 1.0);
      osc.connect(gain).connect(dest);
      noise.connect(filter).connect(gain).connect(dest);
      lfo.start(t);
      osc.start(t);
      noise.start(t);
      lfo.stop(t + 1.0);
      osc.stop(t + 1.0);
      noise.stop(t + 1.0);
    },

    'ambiance_rain': (ctx, dest) => {
      const bufferSize = 2 * ctx.sampleRate;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const output = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }
      const noiseNode = ctx.createBufferSource();
      noiseNode.buffer = buffer;
      noiseNode.loop = true;
      const filter = ctx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.setValueAtTime(1000, ctx.currentTime);
      noiseNode.connect(filter).connect(dest);
      noiseNode.start(ctx.currentTime);
      return {
        noiseNode
      };
    },

    'effect_thunder': (ctx, dest) => {
      const t = ctx.currentTime;
      const duration = 2.5;
      const bufferSize = ctx.sampleRate * duration;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const output = buffer.getChannelData(0);
      let lastOut = 0;
      for (let i = 0; i < bufferSize; i++) {
        const white = Math.random() * 2 - 1;
        output[i] = (lastOut + (0.02 * white)) / 1.02;
        lastOut = output[i];
        output[i] *= 3.5;
      }
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(120, t);
      filter.frequency.linearRampToValueAtTime(40, t + duration);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(1.0, t + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.01, t + duration);
      noise.connect(filter).connect(gain).connect(dest);
      noise.start(t);
      noise.stop(t + duration);
    },

    'player_take_damage': (ctx, dest) => {
      const t = ctx.currentTime;
      const osc = ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(120, t);
      osc.frequency.exponentialRampToValueAtTime(80, t + 0.15);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
      osc.connect(gain).connect(dest);
      osc.start(t);
      osc.stop(t + 0.15);
    },

    'door_open_creak': (ctx, dest) => {
      const t = ctx.currentTime;
      const osc = ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(120, t);
      osc.frequency.linearRampToValueAtTime(150, t + 0.4);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.2, t + 0.1);
      gain.gain.setValueAtTime(0.2, t + 0.4);
      gain.gain.linearRampToValueAtTime(0, t + 0.5);
      osc.connect(gain).connect(dest);
      osc.start(t);
      osc.stop(t + 0.5);
    },

    'key_pickup': (ctx, dest) => {
      const t = ctx.currentTime;
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(1200, t);
      osc.frequency.linearRampToValueAtTime(1800, t + 0.15);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
      osc.connect(gain).connect(dest);
      osc.start(t);
      osc.stop(t + 0.15);
    },

    'swan_heal': (ctx, dest) => {
      const t = ctx.currentTime;
      const osc = ctx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(1500, t);
      osc.frequency.exponentialRampToValueAtTime(3000, t + 0.3);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.4, t + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      osc.connect(gain).connect(dest);
      osc.start(t);
      osc.stop(t + 0.3);
    }
  },

  playSound: function(name) {
    if (!this.isInitialized) this.init();
    if (!this.isInitialized || !this.sounds[name]) return;
    this.sounds[name](this.context, this.mainGain);
  },

  playSoundThrottled: function(name, delay) {
    if (!this.isInitialized || this.soundCooldowns[name]) {
      return;
    }
    this.playSound(name);
    this.soundCooldowns[name] = true;
    setTimeout(() => {
      this.soundCooldowns[name] = false;
    }, delay);
  },

  startAmbiance: function(name) {
    if (!this.isInitialized) this.init();
    if (!this.isInitialized || !this.sounds[name] || this.activeAmbiance[name]) return;
    console.log('Starting ambiance:', name);
    const gain = this.context.createGain();
    gain.connect(this.mainGain);
    gain.gain.setValueAtTime(0, this.context.currentTime);
    let targetVolume = 0.4;
    if (name === 'night_ambiance') targetVolume = 0.3;
    if (name === 'ambiance_rain') targetVolume = 0.008;
    gain.gain.linearRampToValueAtTime(targetVolume, this.context.currentTime + 3);
    const nodes = this.sounds[name](this.context, gain);
    this.activeAmbiance[name] = {
      ...nodes,
      gainNode: gain
    };
  },

  stopAmbiance: function(name) {
    if (!this.isInitialized || !this.activeAmbiance[name]) return;
    console.log('Stopping ambiance:', name);
    const nodes = this.activeAmbiance[name];
    const fadeTime = this.context.currentTime + 2;
    nodes.gainNode.gain.cancelScheduledValues(this.context.currentTime);
    nodes.gainNode.gain.linearRampToValueAtTime(0.001, fadeTime);
    setTimeout(() => {
      if (nodes.noiseNode) nodes.noiseNode.stop();
      if (nodes.lfo) nodes.lfo.stop();
      nodes.gainNode.disconnect();
    }, 2100);
    delete this.activeAmbiance[name];
  },

  startBirdSounds: function() {
    if (!this.isInitialized || this.birdChirpTimer) return;
    console.log("Starting bird sounds...");
    const birdSounds = ['bird_chirp_1', 'bird_chirp_2', 'bird_chirp_3'];
    const loop = () => {
      const randomDelay = Math.random() * 10000 + 5000;
      this.birdChirpTimer = setTimeout(() => {
        if (!this.isInitialized) return;
        const soundName = birdSounds[Math.floor(Math.random() * birdSounds.length)];
        this.playSound(soundName);
        loop();
      }, randomDelay);
    };
    loop();
  },

  stopBirdSounds: function() {
    if (this.birdChirpTimer) {
      console.log("Stopping bird sounds...");
      clearTimeout(this.birdChirpTimer);
      this.birdChirpTimer = null;
    }
  },

  startNightSounds: function() {
    if (!this.isInitialized) return;
    this.startAmbiance('night_ambiance');
    if (this.owlHootTimer) return;
    console.log("Starting owl sounds...");
    const loop = () => {
      const randomDelay = Math.random() * 15000 + 15000;
      this.owlHootTimer = setTimeout(() => {
        if (!this.isInitialized) return;
        this.playSound('owl_hoot');
        loop();
      }, randomDelay);
    };
    loop();
  },

  stopNightSounds: function() {
    this.stopAmbiance('night_ambiance');
    if (this.owlHootTimer) {
      console.log("Stopping owl sounds...");
      clearTimeout(this.owlHootTimer);
      this.owlHootTimer = null;
    }
  }
};

document.addEventListener('DOMContentLoaded', () => {
  const WORLD_SIZE = {
    rows: 150,
    cols: 150
  };
  const DAY_DURATION = 300;
  const NIGHT_DURATION = 180;
  const PLAYER_SPEED = 200;
  const MONSTER_ATTACK_SPEED = 1500;
  const NIGHT_STRENGTH_BONUS = 1.75;
  const CROSSBOW_BASE_DAMAGE = 10;
  const CROSSBOW_STRENGTH_DAMAGE_FACTOR = 4;
  const BOSS_AGGRO_RANGE = 3;
  const BOSS_CHASE_RANGE = 8;
  const GATHERING_HITS = 5;
  const GATHER_HP_COST = 10;
  const WOOD_PER_TREE = 3;
  const STONE_PER_ROCK = 2;
  const GEM_PER_ROCK = 1;
  const HERB_PER_PLANT = 1;
  const BASE_SHELTER_WOOD_COST = 15;
  const BASE_SHELTER_HP_COST = 10;
  const SHELTER_COST_WOOD_PER_LEVEL = 5;
  const SHELTER_COST_HP_PER_LEVEL = 5;
  const BASE_CROSSBOW_WOOD_COST = 30;
  const BASE_CROSSBOW_HP_COST = 25;
  const CROSSBOW_COST_WOOD_PER_LEVEL = 10;
  const CROSSBOW_COST_HP_PER_LEVEL = 10;
  const ARROW_CRAFTING_COST = 20;
  const STONE_SWORD_COST = 20;
  const STONE_SLEDGE_COST = 80;
  const MIN_FOOD_COUNT = 25;
  const FOOD_RESPAWN_AMOUNT = 20;

  const TILE = {
    PLAYER: '',
    EMPTY: ' ',
    WALL_1: '',
    WALL_2: '',
    STONE: '',
    DECOR_1: '',
    DECOR_2: '',
    DECOR_3: '',
    DOOR: '',
    KEY: '',
    MONSTER_1: '',
    MONSTER_2: '',
    MONSTER_3: '',
    BOSS: '',
    U_MONSTER_1: '',
    U_MONSTER_2: '',
    U_MONSTER_3: '',
    U_BOSS: '',
    FOOD_1: '',
    FOOD_2: '',
    DEAD: '',
    PATH: '',
    UW_PATH: '',
    SHELTER: '',
    CROSSBOW: '',
    ARROW: '',
    GHOST: '',
    STONE_SWORD: '',
    STONE_SLEDGE: '',
    WATER: '',
    SWAN: '',
    TRADER: '',
    WISE_OLD_MAN: '',
    GEM: '',
    HERB: '',
    UNICORN: '',
    CAGE: '',
    UNICORN_KEY: ''
  };

  const WEAPONS = {
    'unarmed': {
      name: 'Unarmed',
      emoji: '',
      type: 'melee',
      damageBonus: 1.0
    },
    'crossbow': {
      name: 'Crossbow',
      emoji: TILE.CROSSBOW,
      type: 'ranged'
    },
    'sword': {
      name: 'Stone Sword',
      emoji: TILE.STONE_SWORD,
      type: 'melee',
      damageBonus: 1.2
    },
    'sledge': {
      name: 'Stone Sledgehammer',
      emoji: TILE.STONE_SLEDGE,
      type: 'melee',
      damageBonus: 1.4
    },
  };

  const WEAPON_HOTBAR_ORDER = ['unarmed', 'crossbow', 'sword', 'sledge'];

  const OBJECT_DATA = {
    [TILE.MONSTER_1]: {
      hp: 25,
      strength: 6,
      xpReward: 10,
      type: 'monster',
      speed: 80
    },
    [TILE.MONSTER_2]: {
      hp: 45,
      strength: 10,
      xpReward: 25,
      type: 'monster',
      speed: 100
    },
    [TILE.MONSTER_3]: {
      hp: 70,
      strength: 15,
      xpReward: 40,
      type: 'monster',
      speed: 120
    },
    [TILE.BOSS]: {
      hp: 200,
      strength: 30,
      xpReward: 100,
      type: 'boss',
      speed: 150
    },
    [TILE.U_MONSTER_1]: {
      hp: 50,
      strength: 12,
      xpReward: 20,
      type: 'monster',
      speed: 90
    },
    [TILE.U_MONSTER_2]: {
      hp: 80,
      strength: 8,
      xpReward: 15,
      type: 'monster',
      speed: 60
    },
    [TILE.U_MONSTER_3]: {
      hp: 60,
      strength: 18,
      xpReward: 35,
      type: 'monster',
      speed: 130
    },
    [TILE.U_BOSS]: {
      hp: 400,
      strength: 45,
      xpReward: 250,
      type: 'boss',
      speed: 160
    },
    [TILE.GHOST]: {
      hp: 50,
      strength: 0,
      xpReward: 5,
      type: 'ghost',
      speed: 180
    },
    [TILE.SWAN]: {
      hp: 999,
      strength: 0,
      xpReward: 0,
      type: 'special',
      speed: 70
    },
    [TILE.FOOD_1]: {
      hpGain: 10,
      type: 'food'
    },
    [TILE.FOOD_2]: {
      hpGain: 20,
      type: 'food'
    },
    [TILE.TRADER]: {
      type: 'npc',
      speed: 50
    },
    [TILE.WISE_OLD_MAN]: {
      type: 'npc',
      speed: 30
    },
    [TILE.UNICORN]: {
      type: 'special'
    }
  };

  const NPC_DATA = {
    [TILE.TRADER]: {
      getDialogue: () => "Greetings, traveler! I have rare goods, if you have the resources.",
      options: (npc) => [{
        text: `Trade 50  for 1 `,
        action: () => {
          if (gameState.player.wood >= 50) {
            gameState.player.wood -= 50;
            gameState.player.gems += 1;
            showMessage(`Trade successful! You received 1 ${TILE.GEM}`);
            updateHUD();
          } else {
            showMessage(`You don't have enough ${TILE.WOOD}!`);
          }
        }
      }, {
        text: "Leave",
        action: "close"
      }]
    },
    [TILE.WISE_OLD_MAN]: {
      getDialogue: () => {
        if (!gameState.player.boughtGemUpgrade) {
          return "Ah, a fellow adventurer! Those gems  you carry... they pulse with latent energy. For 10 gems, I can unlock your true potential and permanently increase your strength! ";
        }
        const dialogues = [
          "The underworld holds treasures beyond imagination, but also deeper dangers.",
          "They say a great beast guards a mythical creature on the 20th floor...",
          "A shelter is the only true safety when the moon is high.",
          "Only a key dropped from the mightiest foe can unlock the ultimate prize."
        ];
        return dialogues[Math.floor(Math.random() * dialogues.length)];
      },
      options: (npc) => {
        let opts = [];
        if (!gameState.player.boughtGemUpgrade) {
          opts.push({
            text: "Trade 10  for +2  Strength",
            action: () => {
              if (gameState.player.gems >= 10) {
                gameState.player.gems -= 10;
                gameState.player.strength += 2;
                gameState.player.boughtGemUpgrade = true;
                showMessage(`You feel a surge of power! Strength permanently increased to ${gameState.player.strength}!`);
                updateHUD();
              } else {
                showMessage(`You don't have 10 ${TILE.GEM}! Return when you do.`);
              }
            }
          });
        }
        opts.push({
          text: gameState.player.boughtGemUpgrade ? "Interesting..." : "I'll think about it.",
          action: "close"
        });
        return opts;
      }
    }
  };

  const gameContainer = document.getElementById('game-container');
  const gameWorld = document.getElementById('game-world');
  const nightOverlay = document.getElementById('night-overlay');
  const rainContainer = document.getElementById('rain-container');
  const lightningFlash = document.getElementById('lightning-flash');
  const hpDisplay = document.getElementById('hp-display');
  const strengthDisplay = document.getElementById('strength-display');
  const weaponBar = document.getElementById('weapon-bar');
  const xpDisplay = document.getElementById('xp-display');
  const levelDisplay = document.getElementById('level-display');
  const keyDisplay = document.getElementById('key-display');
  const woodDisplay = document.getElementById('wood-display');
  const stoneDisplay = document.getElementById('stone-display');
  const gemDisplay = document.getElementById('gem-display');
  const herbDisplay = document.getElementById('herb-display');
  const arrowsDisplay = document.getElementById('arrows-display');
  const timeDisplay = document.getElementById('time-display');
  const messageOverlay = document.getElementById('message-overlay');
  const messageBox = document.getElementById('message-box');
  const messageText = document.getElementById('message-text');
  const messageOptions = document.getElementById('message-options');
  const messageButton = document.getElementById('message-button');
  const saveGameButton = document.getElementById('save-game-button');
  const howToPlayButton = document.getElementById('how-to-play-button');

  let gameState = {};
  let mapGrid, playerElement;
  let gameLoopInterval = null;
  let mainGameLoopId = null;
  let playerFloatingTextContainer;
  let cellSize = (8 * Math.min(window.innerWidth, window.innerHeight)) / 100;
  const keysPressed = {};
  let lastFrameTime = 0;
  let visibleCellElements = {};
  let visibleMonsterElements = {};
  let visibleNpcElements = {};
  let messageQueue = [];
  let isDisplayingMessage = false;

  function showFloatingText(htmlContent) {
    if (!playerFloatingTextContainer) return;
    const textElement = document.createElement('div');
    textElement.className = 'floating-text';
    textElement.innerHTML = htmlContent;
    playerFloatingTextContainer.appendChild(textElement);
    setTimeout(() => {
      textElement.remove();
    }, 3000);
  }

  function showMessage(htmlContent, onConfirm, options = []) {
    if (!onConfirm && options.length === 0) {
      showFloatingText(htmlContent);
    } else {
      messageQueue.push({
        htmlContent,
        onConfirm,
        options
      });
      processMessageQueue();
    }
  }

  function processMessageQueue() {
    if (isDisplayingMessage || messageQueue.length === 0) {
      return;
    }
    isDisplayingMessage = true;
    const {
      htmlContent,
      onConfirm,
      options
    } = messageQueue.shift();
    messageText.innerHTML = htmlContent;
    messageOptions.innerHTML = '';
    if (options && options.length > 0) {
      messageBox.classList.add('has-options');
      options.forEach(opt => {
        const btn = document.createElement('button');
        btn.className = 'message-option-button';
        btn.textContent = opt.text;
        btn.onclick = () => {
          if (opt.action && typeof opt.action === 'function') {
            opt.action();
          }
          closeModal();
        };
        messageOptions.appendChild(btn);
      });
    } else {
      messageBox.classList.remove('has-options');
      messageButton.onclick = () => {
        if (onConfirm) onConfirm();
        closeModal();
      };
    }
    messageOverlay.classList.remove('hidden');
  }

  function closeModal() {
    messageOverlay.classList.add('hidden');
    isDisplayingMessage = false;
    messageButton.onclick = null;
    messageOptions.innerHTML = '';
    processMessageQueue();
  }

  function showHowToPlay() {
    const costs = gameState.levelConfig;
    const instructions = `
<h2 class="how-to-play-title"> How to Play (Level ${gameState.level}) </h2>
<div class="how-to-play-columns">
<div class="how-to-play-column">
<h3>Your Goal </h3>
<p>Find the key , unlock the door , and advance. Your ultimate quest is to reach <strong>Level 20 and rescue the captive Unicorn !</strong></p>
<h3>Your Attributes</h3>
<ul>
<li><strong> Health:</strong> Your life force. Restore it by eating food (, ), touching the magic swan , or crafting potions ().</li>
<li><strong> Strength:</strong> Your attack power. Increased by gaining XP or trading with the Wise Old Man .</li>
<li><strong> XP:</strong> Earned by defeating monsters.</li>
<li><strong> Wood/ Stone/ Gems/ Herbs:</strong> Crafting and trading resources. Cost health to gather.</li>
<li>Every 5th level (5, 10, 15) is a dark underworld where you can find gems  and stone .</li>
</ul>
</div>
<div class="how-to-play-column">
<h3>Actions & Controls</h3>
<p>Remember, crafting and building cost both resources and Health !</p>
<ul>
<li><strong>WASD / Arrow Keys:</strong> Movement.</li>
<li><strong>'E' Key:</strong> Interact with characters (, ) when you are next to them.</li>
<li><strong>Number Keys (1,2,3...):</strong> Switch active weapon.</li>
<li><strong>Click on ///:</strong> Gather resource (costs health).</li>
<li><strong>'B' Key:</strong> Build shelter (costs ${costs.shelterWoodCost} , ${costs.shelterHPCost} ).</li>
<li><strong>'C' Key:</strong> Craft Crossbow (costs ${costs.crossbowWoodCost} ).</li>
<li><strong>'P' Key:</strong> Craft arrows (costs ${ARROW_CRAFTING_COST} ).</li>
<li><strong>'V' Key:</strong> Craft Stone Sword (costs ${STONE_SWORD_COST} ).</li>
<li><strong>'H' Key:</strong> Craft Stone Sledgehammer (costs ${STONE_SLEDGE_COST} ).</li>
<li><strong>'M' Key:</strong> Craft Health Potion (costs 5 ).</li>
<li><strong>Right-Click:</strong> Shoot (if crossbow is equipped).</li>
</ul>
</div>
</div>
<ul style="text-align: left; list-style-position: inside; padding-left: 0;">
<li>Fear the night ()! Monsters are stronger. A shelter () is your best friend.</li>
<li>Look for friendly faces! Traders  and wise men  can help you on your quest.</li>
<li>At night, ghosts  hunt! If they catch you outside, they'll steal your items.</li>
<li>&copy; Johnny Heggelund</li>
</ul>`;
    showMessage(instructions, () => {});
  }

  function setupNewGame() {
    if (gameLoopInterval) clearInterval(gameLoopInterval);
    if (mainGameLoopId) cancelAnimationFrame(mainGameLoopId);
    audioManager.stopAmbiance('wind_ambiance');
    audioManager.stopBirdSounds();
    audioManager.stopNightSounds();
    audioManager.stopAmbiance('ambiance_rain');
    const oldPlayer = gameState.player;
    const currentLevel = gameState.level ? gameState.level + 1 : 1;
    const isUnderworld = currentLevel % 5 === 0 && currentLevel < 20;
    gameContainer.style.backgroundColor = isUnderworld ? '#2d2d3a' : '#245E28';
    if (isUnderworld) {
      initRainEffect(100);
    } else {
      stopRainEffect();
      audioManager.startAmbiance('wind_ambiance');
      audioManager.startBirdSounds();
    }
    nightOverlay.classList.remove('is-night');
    gameState = {
      level: currentLevel,
      isUnderworld: isUnderworld,
      player: {
        hp: 100,
        maxHp: 100,
        hasKey: false,
        hasUnicornKey: false,
        wood: 0,
        stone: 0,
        gems: 0,
        herbs: 0,
        arrows: 0,
        inventory: ['unarmed'],
        equippedWeapon: 'unarmed',
        pos: {
          x: Math.floor(WORLD_SIZE.cols / 2),
          y: Math.floor(WORLD_SIZE.rows / 2)
        },
        pixelPos: {
          x: 0,
          y: 0
        },
      },
      world: [],
      monsters: [],
      npcs: [],
      resources: [],
      time: 0,
      timeOfDay: 'day',
      isGameOver: false,
      isFighting: false,
      activeFighter: null,
      monsterAttackInterval: null,
      playerStatusBar: null,
      activeProjectiles: [],
    };
    if (oldPlayer) {
      gameState.player.strength = oldPlayer.strength;
      gameState.player.xp = oldPlayer.xp;
      gameState.player.xpForNextStrength = oldPlayer.xpForNextStrength;
      gameState.player.inventory = oldPlayer.inventory || ['unarmed'];
      gameState.player.equippedWeapon = oldPlayer.equippedWeapon || 'unarmed';
      gameState.player.wood = oldPlayer.wood;
      gameState.player.stone = oldPlayer.stone;
      gameState.player.gems = oldPlayer.gems;
      gameState.player.herbs = oldPlayer.herbs;
      gameState.player.arrows = oldPlayer.arrows;
    } else {
      gameState.player.strength = 5;
      gameState.player.xp = 0;
      gameState.player.xpForNextStrength = 20;
    }
    gameState.levelConfig = {
      shelterWoodCost: BASE_SHELTER_WOOD_COST + SHELTER_COST_WOOD_PER_LEVEL * (gameState.level - 1),
      shelterHPCost: BASE_SHELTER_HP_COST + SHELTER_COST_HP_PER_LEVEL * (gameState.level - 1),
      crossbowWoodCost: BASE_CROSSBOW_WOOD_COST + CROSSBOW_COST_WOOD_PER_LEVEL * (gameState.level - 1),
      crossbowHPCost: BASE_CROSSBOW_HP_COST + CROSSBOW_COST_HP_PER_LEVEL * (gameState.level - 1),
    };
    if (currentLevel === 20) {
      generateUnicornLevel();
    } else if (isUnderworld) {
      generateUnderworld();
    } else {
      generateRealisticWorld();
    }
    const startPos = gameState.player.pos;
    gameState.player.pixelPos = {
      x: startPos.x * cellSize + cellSize / 2,
      y: startPos.y * cellSize + cellSize / 2,
    };
    createWorldElements();
    updateVisibleCells(true);
    render();
    updateHUD();
    gameLoopInterval = setInterval(gameTick, 1000);
    lastFrameTime = performance.now();
    mainGameLoopId = requestAnimationFrame(mainGameLoop);
  }

  function exportSaveFile() {
    if (gameState.isFighting) {
      showMessage("Cannot export during combat!");
      return;
    }
    try {
      const stateToSave = JSON.parse(JSON.stringify(gameState));
      stateToSave.monsters = stateToSave.monsters.filter(m => !m.isDying);
      delete stateToSave.playerStatusBar;
      delete stateToSave.activeProjectiles;
      delete stateToSave.levelConfig;
      delete stateToSave.monsterAttackInterval;
      const json = JSON.stringify(stateToSave);
      const blob = new Blob([json], {
        type: "application/json"
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `Adventure_Lvl${gameState.level}_HP${gameState.player.hp}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showMessage("Game exported successfully! ");
    } catch (e) {
      console.error(e);
      showMessage("Error exporting game.");
    }
  }

  function importSaveFile(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
      try {
        const json = event.target.result;
        const check = JSON.parse(json);
        if (!check.player || !check.world) {
          alert("Invalid save file!");
          return;
        }
        if (confirm("Importing will overwrite your current game. Continue?")) {
          localStorage.setItem('adventureGameSaveData', json);
          if (loadGame()) {
            showMessage("Game imported successfully! ");
          } else {
            showMessage("Failed to load the imported save.");
          }
        }
      } catch (err) {
        console.error(err);
        alert("Error reading file.");
      }
      e.target.value = '';
    };
    reader.readAsText(file);
  }

  function saveGame() {
    if (gameState.isFighting) {
      showMessage("Cannot save during combat!");
      return;
    }
    try {
      const stateToSave = JSON.parse(JSON.stringify(gameState));
      stateToSave.monsters = stateToSave.monsters.filter(m => !m.isDying);
      delete stateToSave.playerStatusBar;
      delete stateToSave.activeProjectiles;
      delete stateToSave.levelConfig;
      delete stateToSave.monsterAttackInterval;
      localStorage.setItem('adventureGameSaveData', JSON.stringify(stateToSave));
      showMessage("Game Saved! ");
    } catch (error) {
      console.error('Failed to save game:', error);
      showMessage("Error: Could not save the game.");
    }
  }

  function loadGame() {
    const savedData = localStorage.getItem('adventureGameSaveData');
    if (!savedData) return false;
    if (gameLoopInterval) clearInterval(gameLoopInterval);
    if (mainGameLoopId) cancelAnimationFrame(mainGameLoopId);
    audioManager.stopAmbiance('wind_ambiance');
    audioManager.stopBirdSounds();
    audioManager.stopNightSounds();
    audioManager.stopAmbiance('ambiance_rain');
    try {
      gameState = JSON.parse(savedData);
      gameState.player.inventory = gameState.player.inventory || ['unarmed'];
      gameState.player.equippedWeapon = gameState.player.equippedWeapon || 'unarmed';
      gameState.player.stone = gameState.player.stone || 0;
      gameState.player.gems = gameState.player.gems || 0;
      gameState.player.herbs = gameState.player.herbs || 0;
      gameState.player.arrows = gameState.player.arrows || 0;
      gameState.player.hasUnicornKey = gameState.player.hasUnicornKey || false;
      gameState.npcs = gameState.npcs || [];
      if (gameState.player.xp === undefined) gameState.player.xp = 0;
      if (gameState.player.xpForNextStrength === undefined) {
        let xpNeeded = 20;
        if (gameState.player.strength > 5) {
          for (let i = 5; i < gameState.player.strength; i++) {
            xpNeeded = Math.floor(xpNeeded * 1.5);
          }
        }
        gameState.player.xpForNextStrength = xpNeeded;
      }
      gameState.player.pixelPos = {
        x: gameState.player.pos.x * cellSize + cellSize / 2,
        y: gameState.player.pos.y * cellSize + cellSize / 2
      };
      const entitiesToUpdate = [...(gameState.monsters || []), ...(gameState.npcs || [])];
      entitiesToUpdate.forEach((m) => {
        m.pixelPos = {
          x: m.x * cellSize + cellSize / 2,
          y: m.y * cellSize + cellSize / 2
        };
        m.targetPixelPos = {
          ...m.pixelPos
        };
      });
      gameState.isUnderworld = gameState.level % 5 === 0 && gameState.level < 20;
      gameContainer.style.backgroundColor = gameState.level === 20 ? '#1a001a' : (gameState.isUnderworld ? '#2d2d3a' : '#245E28');
      if (gameState.isUnderworld) {
        initRainEffect(100);
      } else {
        stopRainEffect();
      }
      gameState.levelConfig = {
        shelterWoodCost: BASE_SHELTER_WOOD_COST + SHELTER_COST_WOOD_PER_LEVEL * (gameState.level - 1),
        shelterHPCost: BASE_SHELTER_HP_COST + SHELTER_COST_HP_PER_LEVEL * (gameState.level - 1),
        crossbowWoodCost: BASE_CROSSBOW_WOOD_COST + CROSSBOW_COST_WOOD_PER_LEVEL * (gameState.level - 1),
        crossbowHPCost: BASE_CROSSBOW_HP_COST + CROSSBOW_COST_HP_PER_LEVEL * (gameState.level - 1),
      };
      gameState.time = gameState.time || 0;
      gameState.timeOfDay = gameState.timeOfDay || 'day';
      gameState.isFighting = false;
      gameState.activeFighter = null;
      gameState.monsterAttackInterval = null;
      gameState.isGameOver = false;
      gameState.playerStatusBar = null;
      gameState.activeProjectiles = [];
      createWorldElements();
      updateVisibleCells(true);
      render();
      updateHUD();
      if (gameState.timeOfDay === 'night') {
        nightOverlay.classList.add('is-night');
        if (!gameState.isUnderworld && gameState.level !== 20) {
          audioManager.startNightSounds();
        }
      } else {
        nightOverlay.classList.remove('is-night');
        if (!gameState.isUnderworld && gameState.level !== 20) {
          audioManager.startAmbiance('wind_ambiance');
          audioManager.startBirdSounds();
        }
      }
      gameLoopInterval = setInterval(gameTick, 1000);
      lastFrameTime = performance.now();
      mainGameLoopId = requestAnimationFrame(mainGameLoop);
      showMessage("Game Loaded!");
      return true;
    } catch (error) {
      console.error('Failed to load game:', error);
      localStorage.removeItem('adventureGameSaveData');
      return false;
    }
  }

  function levelUp() {
    showMessage(`Congratulations! You reached level ${gameState.level + 1}! The challenges grow tougher...`, setupNewGame);
  }

  function gameOver() {
    gameState.isGameOver = true;
    audioManager.stopAmbiance('wind_ambiance');
    audioManager.stopBirdSounds();
    audioManager.stopNightSounds();
    audioManager.stopAmbiance('ambiance_rain');
    clearInterval(gameLoopInterval);
    cancelAnimationFrame(mainGameLoopId);
    showMessage("GAME OVER <br>Loading last save...", () => {
      if (!loadGame()) {
        window.location.reload();
      }
    });
  }

  function gameWon() {
    gameState.isGameOver = true;
    audioManager.stopAmbiance('wind_ambiance');
    audioManager.stopBirdSounds();
    audioManager.stopNightSounds();
    audioManager.stopAmbiance('ambiance_rain');
    clearInterval(gameLoopInterval);
    cancelAnimationFrame(mainGameLoopId);
    localStorage.removeItem('adventureGameSaveData');
    const winContent = `<h2> VICTORY! </h2><p>You have defeated the great dragon and used its key to free the mystical Unicorn!<br><br>The land is safe once more, thanks to your courage. You are a true hero!</p>`;
    showMessage(winContent, null, [{
      text: "Play Again",
      action: () => window.location.reload()
    }]);
  }

  function findValidSpotNear(targetPos, searchRadius = 5) {
    const pathTile = gameState.isUnderworld ? TILE.UW_PATH : TILE.PATH;
    for (let r = 1; r <= searchRadius; r++) {
      for (let i = -r; i <= r; i++) {
        for (let j = -r; j <= r; j++) {
          if (Math.abs(i) !== r && Math.abs(j) !== r) continue;
          const checkX = targetPos.x + i;
          const checkY = targetPos.y + j;
          if (checkX >= 0 && checkX < WORLD_SIZE.cols && checkY >= 0 && checkY < WORLD_SIZE.rows) {
            const tile = gameState.world[checkY][checkX];
            if (tile === TILE.EMPTY || tile === pathTile) {
              return {
                x: checkX,
                y: checkY
              };
            }
          }
        }
      }
    }
    return null;
  }

  function generateLake() {
    const lakeSize = 15 + Math.floor(Math.random() * 10);
    const center = {
      x: Math.floor(WORLD_SIZE.cols * (0.2 + Math.random() * 0.6)),
      y: Math.floor(WORLD_SIZE.rows * (0.2 + Math.random() * 0.6)),
    };
    let lakeTiles = [{
      ...center
    }];
    gameState.world[center.y][center.x] = TILE.WATER;
    for (let i = 0; i < lakeSize * lakeSize * 0.8; i++) {
      const randomTile = lakeTiles[Math.floor(Math.random() * lakeTiles.length)];
      const directions = [
        [0, -1],
        [0, 1],
        [-1, 0],
        [1, 0]
      ];
      const move = directions[Math.floor(Math.random() * 4)];
      const newTile = {
        x: randomTile.x + move[0],
        y: randomTile.y + move[1]
      };
      if (newTile.x >= 1 && newTile.x < WORLD_SIZE.cols - 1 && newTile.y >= 1 && newTile.y < WORLD_SIZE.rows - 1) {
        if (gameState.world[newTile.y][newTile.x] !== TILE.WATER) {
          gameState.world[newTile.y][newTile.x] = TILE.WATER;
          lakeTiles.push(newTile);
        }
      }
    }
  }

  function generateRealisticWorld() {
    gameState.world = Array.from({
      length: WORLD_SIZE.rows
    }, () => Array(WORLD_SIZE.cols).fill(TILE.EMPTY));
    gameState.resources = [];
    gameState.monsters = [];
    gameState.npcs = [];
    generateLake();
    for (let y = 0; y < WORLD_SIZE.rows; y++) {
      for (let x = 0; x < WORLD_SIZE.cols; x++) {
        if (gameState.world[y][x] === TILE.EMPTY && Math.random() < 0.45) {
          gameState.world[y][x] = TILE.WALL_1;
        }
      }
    }
    for (let i = 0; i < 4; i++) {
      let nextWorld = JSON.parse(JSON.stringify(gameState.world));
      for (let y = 1; y < WORLD_SIZE.rows - 1; y++) {
        for (let x = 1; x < WORLD_SIZE.cols - 1; x++) {
          if (gameState.world[y][x] === TILE.WATER) continue;
          let neighbors = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              if (gameState.world[y + dy][x + dx] === TILE.WALL_1) neighbors++;
            }
          }
          if (neighbors > 4) nextWorld[y][x] = TILE.WALL_1;
          else if (neighbors < 4) nextWorld[y][x] = TILE.EMPTY;
        }
      }
      gameState.world = nextWorld;
    }
    const startPos = getRandomEmptyPosition(TILE.EMPTY, [], 1);
    if (!startPos) {
      showMessage("Could not generate the map...", () => window.location.reload(), []);
      return;
    }
    const doorPos = getRandomEmptyPosition(TILE.EMPTY, [startPos], 50);
    if (!doorPos) {
      showMessage("Could not generate the map...", () => window.location.reload(), []);
      return;
    }
    const keyPos = getRandomEmptyPosition(TILE.EMPTY, [startPos, doorPos], 40);
    if (!keyPos) {
      showMessage("Could not generate the map...", () => window.location.reload(), []);
      return;
    }
    gameState.player.pos = startPos;
    gameState.keyPos = keyPos;
    gameState.doorPos = doorPos;
    carvePath(startPos, keyPos, 2);
    carvePath(startPos, doorPos, 2);
    carvePath(keyPos, doorPos, 1);
    const bossHomePos = findValidSpotNear(doorPos, 8);
    if (bossHomePos) {
      placeMonsters(TILE.BOSS, 1, bossHomePos);
    } else {
      placeMonsters(TILE.BOSS, 1);
    }
    for (let y = 0; y < WORLD_SIZE.rows; y++) {
      for (let x = 0; x < WORLD_SIZE.cols; x++) {
        if ([TILE.WALL_1, TILE.WALL_2].includes(gameState.world[y][x])) {
          gameState.resources.push({
            x,
            y,
            hits: 0,
            type: 'tree'
          });
        }
      }
    }
    placeObjectsInBiome(TILE.WALL_2, 300, TILE.WALL_1);
    placeObjectsInBiome(TILE.FOOD_1, 60, TILE.EMPTY);
    placeObjectsInBiome(TILE.FOOD_2, 40, TILE.EMPTY);
    placeObjectsInBiome(TILE.HERB, 30, TILE.EMPTY);
    placeFlowerBeds(30, 5);
    placeMonsters(TILE.MONSTER_1, 40);
    placeMonsters(TILE.MONSTER_2, 25);
    placeMonsters(TILE.MONSTER_3, 10);
    const swanPos = getRandomEmptyPosition(TILE.WATER, [], 0);
    if (swanPos) {
      placeMonsters(TILE.SWAN, 1, swanPos);
    }
    placeNPCs(TILE.TRADER, 1 + Math.floor(gameState.level / 4));
    placeNPCs(TILE.WISE_OLD_MAN, 1 + Math.floor(gameState.level / 6));
  }

  function generateUnderworld() {
    gameState.world = Array.from({
      length: WORLD_SIZE.rows
    }, () => Array(WORLD_SIZE.cols).fill(TILE.EMPTY));
    gameState.resources = [];
    gameState.monsters = [];
    gameState.npcs = [];
    placeResourceClusters(TILE.STONE, 80, 8);
    placeResourceClusters(TILE.WALL_1, 95, 5);
    placeResourceClusters(TILE.GEM, 40, 4);
    const startPos = getRandomEmptyPosition(TILE.EMPTY, [], 1);
    if (!startPos) {
      showMessage("Could not generate the map...", () => window.location.reload(), []);
      return;
    }
    const doorPos = getRandomEmptyPosition(TILE.EMPTY, [startPos], 50);
    if (!doorPos) {
      showMessage("Could not generate the map...", () => window.location.reload(), []);
      return;
    }
    const keyPos = getRandomEmptyPosition(TILE.EMPTY, [startPos, doorPos], 40);
    if (!keyPos) {
      showMessage("Could not generate the map...", () => window.location.reload(), []);
      return;
    }
    gameState.player.pos = startPos;
    gameState.keyPos = keyPos;
    gameState.doorPos = doorPos;
    carvePath(startPos, keyPos, 2);
    carvePath(startPos, doorPos, 2);
    carvePath(keyPos, doorPos, 1);
    const bossHomePos = findValidSpotNear(doorPos, 8);
    if (bossHomePos) {
      placeMonsters(TILE.U_BOSS, 1, bossHomePos);
    } else {
      placeMonsters(TILE.U_BOSS, 1);
    }
    placeObjectsInBiome(TILE.FOOD_1, 60, TILE.EMPTY);
    placeObjectsInBiome(TILE.FOOD_2, 45, TILE.EMPTY);
    placeMonsters(TILE.U_MONSTER_1, 30);
    placeMonsters(TILE.U_MONSTER_2, 20);
    placeMonsters(TILE.U_MONSTER_3, 15);
    placeNPCs(TILE.TRADER, 1 + Math.floor(gameState.level / 4));
  }

  function generateUnicornLevel() {
    gameState.world = Array.from({
      length: WORLD_SIZE.rows
    }, () => Array(WORLD_SIZE.cols).fill(TILE.EMPTY));
    gameState.resources = [];
    gameState.monsters = [];
    gameState.npcs = [];
    gameContainer.style.backgroundColor = '#1a001a';
    const arena_x = Math.floor(WORLD_SIZE.cols / 2);
    const arena_y = Math.floor(WORLD_SIZE.rows / 2);
    const arena_radius = 25;
    for (let y = 0; y < WORLD_SIZE.rows; y++) {
      for (let x = 0; x < WORLD_SIZE.cols; x++) {
        const dist = Math.hypot(x - arena_x, y - arena_y);
        if (dist > arena_radius) {
          gameState.world[y][x] = TILE.STONE;
        } else if (dist > arena_radius - 2) {
          gameState.world[y][x] = TILE.DECOR_1;
        }
      }
    }
    const startPos = {
      x: arena_x,
      y: arena_y + 20
    };
    gameState.player.pos = startPos;
    const unicornPos = {
      x: arena_x,
      y: arena_y - 20
    };
    gameState.unicornPos = unicornPos;
    for (let i = -1; i <= 1; i++) {
      for (let j = -1; j <= 1; j++) {
        if (i === 0 && j === 0) continue;
        gameState.world[unicornPos.y + j][unicornPos.x + i] = TILE.CAGE;
      }
    }
    placeSpecial(TILE.UNICORN, 1, unicornPos);
    const bossPos = {
      x: arena_x,
      y: arena_y
    };
    placeMonsters(TILE.U_BOSS, 1, bossPos);
    placeMonsters(TILE.U_MONSTER_3, 10);
    placeObjectsInBiome(TILE.FOOD_2, 15, TILE.EMPTY);
    gameState.doorPos = {
      x: -1,
      y: -1
    };
    gameState.keyPos = {
      x: -1,
      y: -1
    };
  }

  function placeResourceClusters(tile, clusterCount, maxClusterSize) {
    for (let i = 0; i < clusterCount; i++) {
      const center = getRandomEmptyPosition(TILE.EMPTY, [gameState.player.pos], 5);
      if (!center) continue;
      const clusterSize = 2 + Math.floor(Math.random() * (maxClusterSize - 1));
      for (let j = 0; j < clusterSize; j++) {
        const angle = Math.random() * 2 * Math.PI;
        const radius = Math.random() * (maxClusterSize / 3);
        const resX = Math.round(center.x + Math.cos(angle) * radius);
        const resY = Math.round(center.y + Math.sin(angle) * radius);
        if (resX >= 0 && resX < WORLD_SIZE.cols && resY >= 0 && resY < WORLD_SIZE.rows) {
          if (gameState.world[resY][resX] === TILE.EMPTY) {
            gameState.world[resY][resX] = tile;
            let resourceType;
            if (tile === TILE.STONE) resourceType = 'stone';
            else if (tile === TILE.GEM) resourceType = 'gem';
            else resourceType = 'tree';
            gameState.resources.push({
              x: resX,
              y: resY,
              hits: 0,
              type: resourceType
            });
          }
        }
      }
    }
  }

  function getRandomEmptyPosition(tileType, pointsToAvoid = [], minDistance = 20) {
    let x, y, tries = 0;
    const maxTries = 10000;
    while (tries < maxTries) {
      x = Math.floor(Math.random() * WORLD_SIZE.cols);
      y = Math.floor(Math.random() * WORLD_SIZE.rows);
      tries++;
      if (x < 0 || x >= WORLD_SIZE.cols || y < 0 || y >= WORLD_SIZE.rows) continue;
      if (gameState.world[y][x] !== tileType) continue;
      let tooClose = false;
      for (const point of pointsToAvoid) {
        if (point && typeof point.x === 'number' && typeof point.y === 'number') {
          if (Math.hypot(x - point.x, y - point.y) < minDistance) {
            tooClose = true;
            break;
          }
        }
      }
      if (tooClose) continue;
      return {
        x,
        y
      };
    }
    console.warn(`Could not find a valid random position for ${tileType} after ${maxTries} tries.`);
    return null;
  }

  function carvePath(start, end, width) {
    let current = {
      ...start
    };
    const pathTile = gameState.isUnderworld ? TILE.UW_PATH : TILE.PATH;
    while (Math.abs(current.x - end.x) > width || Math.abs(current.y - end.y) > width) {
      for (let i = -width; i <= width; i++) {
        for (let j = -width; j <= width; j++) {
          if (current.y + i >= 0 && current.y + i < WORLD_SIZE.rows && current.x + j >= 0 && current.x + j < WORLD_SIZE.cols) {
            if (gameState.world[current.y + i][current.x + j] === TILE.EMPTY) {
              gameState.world[current.y + i][current.x + j] = pathTile;
            }
          }
        }
      }
      if (Math.random() > 0.5) {
        current.x += Math.sign(end.x - current.x);
      } else {
        current.y += Math.sign(end.y - current.y);
      }
    }
  }

  function placeFlowerBeds(bedCount, maxClusterSize) {
    for (let i = 0; i < bedCount; i++) {
      const center = getRandomEmptyPosition(TILE.EMPTY, [gameState.player.pos]);
      if (!center) continue;
      const clusterSize = 2 + Math.floor(Math.random() * (maxClusterSize - 1));
      for (let j = 0; j < clusterSize; j++) {
        const offsetX = Math.floor(Math.random() * 3) - 1;
        const offsetY = Math.floor(Math.random() * 3) - 1;
        const flowerX = center.x + offsetX;
        const flowerY = center.y + offsetY;
        if (flowerX >= 0 && flowerX < WORLD_SIZE.cols && flowerY >= 0 && flowerY < WORLD_SIZE.rows) {
          if (gameState.world[flowerY][flowerX] === TILE.EMPTY) {
            const flowerType = Math.random() < 0.5 ? TILE.DECOR_2 : TILE.DECOR_3;
            gameState.world[flowerY][flowerX] = flowerType;
          }
        }
      }
    }
  }

  function placeObjectsInBiome(tile, count, targetBiome, shouldUpdateCells = false) {
    const isResource = [TILE.HERB, TILE.GEM].includes(tile);
    for (let i = 0; i < count; i++) {
      const pos = getRandomEmptyPosition(targetBiome, [gameState.player.pos]);
      if (pos) {
        gameState.world[pos.y][pos.x] = tile;
        if (isResource) {
          gameState.resources.push({
            x: pos.x,
            y: pos.y,
            hits: 0,
            type: tile === TILE.HERB ? 'herb' : 'gem'
          });
        }
        if (shouldUpdateCells) {
          updateCell(pos.x, pos.y, tile);
        }
      }
    }
  }

  function placeMonsters(tile, count, fixedPos = null) {
    for (let i = 0; i < count; i++) {
      let pos = fixedPos;
      if (!pos) {
        const tileType = tile === TILE.SWAN ? TILE.WATER : TILE.EMPTY;
        pos = getRandomEmptyPosition(tileType, [gameState.player.pos], 10);
      }
      if (!pos) continue;
      const baseStats = OBJECT_DATA[tile];
      const isSpecial = [TILE.SWAN, TILE.GHOST].includes(tile);
      const levelMultiplier = isSpecial ? 1 : 1 + 0.35 * (gameState.level - 1);
      const finalHp = Math.floor(baseStats.hp * levelMultiplier);
      const finalStrength = Math.floor(baseStats.strength * levelMultiplier);
      const xPx = pos.x * cellSize + cellSize / 2;
      const yPx = pos.y * cellSize + cellSize / 2;
      const isBoss = OBJECT_DATA[tile].type === 'boss';
      const monsterData = {
        id: `m-${Date.now()}-${Math.random()}`,
        tile: tile,
        x: pos.x,
        y: pos.y,
        baseHp: finalHp,
        currentHp: finalHp,
        baseStrength: finalStrength,
        currentStrength: finalStrength,
        isAggroed: false,
        isDying: false,
        pixelPos: {
          x: xPx,
          y: yPx
        },
        targetPixelPos: {
          x: xPx,
          y: yPx
        },
        speed: OBJECT_DATA[tile].speed,
        isBoss: isBoss,
        isHunting: false,
      };
      if (isBoss) {
        monsterData.homePos = {
          x: pos.x,
          y: pos.y
        };
      }
      gameState.monsters.push(monsterData);
    }
  }

  function placeNPCs(tile, count) {
    for (let i = 0; i < count; i++) {
      const pos = getRandomEmptyPosition(TILE.EMPTY, [gameState.player.pos], 15);
      if (!pos) continue;
      const xPx = pos.x * cellSize + cellSize / 2;
      const yPx = pos.y * cellSize + cellSize / 2;
      const npc = {
        id: `npc-${Date.now()}-${Math.random()}`,
        tile: tile,
        x: pos.x,
        y: pos.y,
        pixelPos: {
          x: xPx,
          y: yPx
        },
        targetPixelPos: {
          x: xPx,
          y: yPx
        },
        speed: OBJECT_DATA[tile].speed,
      };
      gameState.npcs.push(npc);
    }
  }

  function placeSpecial(tile, count, fixedPos = null) {
    for (let i = 0; i < count; i++) {
      let pos = fixedPos || getRandomEmptyPosition(TILE.EMPTY, [gameState.player.pos], 10);
      if (!pos) continue;
      const xPx = pos.x * cellSize + cellSize / 2;
      const yPx = pos.y * cellSize + cellSize / 2;
      const specialObject = {
        id: `s-${Date.now()}-${Math.random()}`,
        tile: tile,
        x: pos.x,
        y: pos.y,
        pixelPos: {
          x: xPx,
          y: yPx
        },
        targetPixelPos: {
          x: xPx,
          y: yPx
        },
        speed: 0,
      };
      gameState.npcs.push(specialObject);
    }
  }

  function createWorldElements() {
    gameWorld.innerHTML = '';
    mapGrid = document.createElement('div');
    mapGrid.id = 'map-grid';
    gameWorld.appendChild(mapGrid);
    playerElement = document.createElement('div');
    playerElement.id = 'player';
    playerFloatingTextContainer = document.createElement('div');
    playerFloatingTextContainer.id = 'player-floating-text-container';
    playerElement.appendChild(playerFloatingTextContainer);
    const playerSprite = document.createElement('div');
    playerSprite.className = 'player-sprite';
    playerSprite.textContent = TILE.PLAYER;
    playerElement.appendChild(playerSprite);
    gameWorld.appendChild(playerElement);
    visibleCellElements = {};
    Object.values(visibleMonsterElements).forEach((el) => el.remove());
    visibleMonsterElements = {};
    Object.values(visibleNpcElements).forEach((el) => el.remove());
    visibleNpcElements = {};
    mapGrid.addEventListener('click', (e) => {
      if (gameState.isGameOver || gameState.isFighting || !e.target.dataset.cellId) return;
      const parts = e.target.dataset.cellId.split('-');
      const x = parseInt(parts[1]);
      const y = parseInt(parts[2]);
      if (gameState.monsters.some((m) => !m.isDying && m.x === x && m.y === y)) return;
      const isAdjacent = Math.abs(x - gameState.player.pos.x) <= 1 && Math.abs(y - gameState.player.pos.y) <= 1;
      if (!isAdjacent) return;
      const resource = gameState.resources.find((r) => r.x === x && r.y === y);
      if (resource) {
        gatherResource(resource, e.target);
      }
    });
  }

  function updateVisibleCells(forceRedraw = false) {
    const pPos = gameState.player.pos;
    const renderDistX = Math.ceil(gameContainer.clientWidth / cellSize / 2) + 1;
    const renderDistY = Math.ceil(gameContainer.clientHeight / cellSize / 2) + 1;
    const newVisible = {};
    const pathTile = gameState.isUnderworld ? TILE.UW_PATH : TILE.PATH;
    for (let y = pPos.y - renderDistY; y <= pPos.y + renderDistY; y++) {
      for (let x = pPos.x - renderDistX; x <= pPos.x + renderDistX; x++) {
        const cellId = `cell-${x}-${y}`;
        newVisible[cellId] = true;
        if (!visibleCellElements[cellId] || forceRedraw) {
          if (forceRedraw && visibleCellElements[cellId]) {
            visibleCellElements[cellId].remove();
          }
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.cellId = cellId;
          cell.style.left = `${x * cellSize}px`;
          cell.style.top = `${y * cellSize}px`;
          if (x < 0 || x >= WORLD_SIZE.cols || y < 0 || y >= WORLD_SIZE.rows) {
            cell.style.backgroundColor = '#000000';
            cell.textContent = '';
          } else {
            let displayTile = gameState.world[y][x];
            if (gameState.level < 20) {
              if (x === gameState.keyPos.x && y === gameState.keyPos.y && !gameState.player.hasKey) {
                displayTile = TILE.KEY;
              } else if (x === gameState.doorPos.x && y === gameState.doorPos.y) {
                displayTile = TILE.DOOR;
              }
            }
            const monsterAtPos = gameState.monsters.find((m) => m.x === x && m.y === y && !m.isDying);
            const npcAtPos = gameState.npcs.find((n) => n.x === x && n.y === y);
            if (monsterAtPos || npcAtPos) {
              if (displayTile !== TILE.KEY && displayTile !== TILE.DOOR) {
                displayTile = gameState.world[y][x] === pathTile ? pathTile : TILE.EMPTY;
              }
            }
            if (gameState.world[y][x] === TILE.WATER) {
              cell.style.backgroundColor = '#42a5f5';
              displayTile = TILE.EMPTY;
            } else {
              cell.style.backgroundColor = 'transparent';
            }
            cell.textContent = displayTile;
            updateCellClass(cell, displayTile);
          }
          mapGrid.appendChild(cell);
          visibleCellElements[cellId] = cell;
        }
      }
    }
    for (const cellId in visibleCellElements) {
      if (!newVisible[cellId]) {
        visibleCellElements[cellId].remove();
        delete visibleCellElements[cellId];
      }
    }
  }

  function render() {
    if (!gameState || gameState.isGameOver) {
      if (playerElement) {
        playerElement.querySelector('.player-sprite').textContent = TILE.DEAD;
        playerElement.classList.remove('is-walking');
      }
      return;
    }
    if (!gameState.player || !gameState.player.pixelPos || !mapGrid) {
      return;
    }
    const screenCenterX = gameContainer.clientWidth / 2;
    const screenCenterY = gameContainer.clientHeight / 2;
    const mapX = screenCenterX - gameState.player.pixelPos.x;
    const mapY = screenCenterY - gameState.player.pixelPos.y;
    mapGrid.style.transform = `translate(${mapX}px, ${mapY}px)`;
    playerElement.style.transform = `translate(${screenCenterX - cellSize / 2}px, ${screenCenterY - cellSize / 2}px)`;
    renderVisibleMonsters();
    renderVisibleNPCs();
  }

  function renderVisibleMonsters() {
    if (!gameState.player || !mapGrid) return;
    const pPos = gameState.player.pos;
    const renderDistX = Math.ceil(gameContainer.clientWidth / cellSize / 2) + 4;
    const renderDistY = Math.ceil(gameContainer.clientHeight / cellSize / 2) + 4;
    const newVisibleMonsters = {};
    for (const monster of gameState.monsters) {
      const isVisible = Math.abs(monster.x - pPos.x) < renderDistX && Math.abs(monster.y - pPos.y) < renderDistY;
      if (isVisible) {
        newVisibleMonsters[monster.id] = true;
        let monsterEl = visibleMonsterElements[monster.id];
        if (!monsterEl) {
          monsterEl = document.createElement('div');
          monsterEl.className = 'monster-container';
          const sprite = document.createElement('div');
          sprite.className = 'monster-sprite';
          sprite.textContent = monster.tile;
          if (OBJECT_DATA[monster.tile].type === 'boss') {
            sprite.classList.add('large');
          } else {
            sprite.classList.add('medium');
          }
          monsterEl.appendChild(sprite);
          mapGrid.appendChild(monsterEl);
          visibleMonsterElements[monster.id] = monsterEl;
          monsterEl.addEventListener('click', () => {
            if (gameState.isGameOver || monster.isDying || monster.tile === TILE.GHOST || monster.tile === TILE.SWAN) return;
            if (gameState.isFighting && gameState.activeFighter.id === monster.id) {
              const equippedWeapon = WEAPONS[gameState.player.equippedWeapon];
              let weaponForThisHit = equippedWeapon;
              if (weaponForThisHit.type === 'ranged') {
                weaponForThisHit = WEAPONS['unarmed'];
              }
              if (weaponForThisHit.name === 'Unarmed') {
                audioManager.playSound('player_attack_unarmed');
              } else if (weaponForThisHit.name === 'Stone Sword') {
                audioManager.playSound('player_attack_sword');
              } else if (weaponForThisHit.name === 'Stone Sledgehammer') {
                audioManager.playSound('player_attack_sledge');
              }
              const damageBonus = weaponForThisHit.damageBonus;
              const baseDamage = gameState.player.strength + Math.floor(Math.random() * 3) - 1;
              const playerDamage = Math.floor(baseDamage * damageBonus);
              gameState.activeFighter.currentHp -= playerDamage;
              updateHealthBar(monsterEl, gameState.activeFighter.currentHp, gameState.activeFighter.baseHp);
              if (gameState.activeFighter.currentHp <= 0) {
                endFight('win');
              }
            } else if (!gameState.isFighting) {
              const isAdjacent = Math.abs(monster.x - gameState.player.pos.x) <= 1 && Math.abs(monster.y - gameState.player.pos.y) <= 1;
              if (isAdjacent) {
                startFight(monster);
                const equippedWeapon = WEAPONS[gameState.player.equippedWeapon];
                let weaponForThisHit = equippedWeapon;
                if (weaponForThisHit.type === 'ranged') {
                  weaponForThisHit = WEAPONS['unarmed'];
                }
                if (weaponForThisHit.name === 'Unarmed') {
                  audioManager.playSound('player_attack_unarmed');
                } else if (weaponForThisHit.name === 'Stone Sword') {
                  audioManager.playSound('player_attack_sword');
                } else if (weaponForThisHit.name === 'Stone Sledgehammer') {
                  audioManager.playSound('player_attack_sledge');
                }
                const damageBonus = weaponForThisHit.damageBonus;
                const baseDamage = gameState.player.strength + Math.floor(Math.random() * 3) - 1;
                const playerDamage = Math.floor(baseDamage * damageBonus);
                if (gameState.activeFighter) {
                  gameState.activeFighter.currentHp -= playerDamage;
                  updateHealthBar(monsterEl, gameState.activeFighter.currentHp, gameState.activeFighter.baseHp);
                  if (gameState.activeFighter.currentHp <= 0) {
                    endFight('win');
                  }
                }
              }
            }
          });
        }
        if (monster.pixelPos) {
          const elX = monster.pixelPos.x - cellSize / 2;
          const elY = monster.pixelPos.y - cellSize / 2;
          monsterEl.style.transform = `translate(${elX}px, ${elY}px)`;
        }
      }
    }
    for (const monsterId in visibleMonsterElements) {
      if (!newVisibleMonsters[monsterId]) {
        visibleMonsterElements[monsterId].remove();
        delete visibleMonsterElements[monsterId];
      }
    }
  }

  function renderVisibleNPCs() {
    if (!gameState.player || !mapGrid) return;
    const pPos = gameState.player.pos;
    const renderDistX = Math.ceil(gameContainer.clientWidth / cellSize / 2) + 4;
    const renderDistY = Math.ceil(gameContainer.clientHeight / cellSize / 2) + 4;
    const newVisibleNPCs = {};
    for (const npc of gameState.npcs) {
      const isVisible = Math.abs(npc.x - pPos.x) < renderDistX && Math.abs(npc.y - pPos.y) < renderDistY;
      if (isVisible) {
        newVisibleNPCs[npc.id] = true;
        let npcEl = visibleNpcElements[npc.id];
        if (!npcEl) {
          npcEl = document.createElement('div');
          npcEl.className = 'npc-container';
          const sprite = document.createElement('div');
          sprite.className = 'npc-sprite';
          sprite.textContent = npc.tile;
          npcEl.appendChild(sprite);
          mapGrid.appendChild(npcEl);
          visibleNpcElements[npc.id] = npcEl;
        }
        if (npc.pixelPos) {
          const elX = npc.pixelPos.x - cellSize / 2;
          const elY = npc.pixelPos.y - cellSize / 2;
          npcEl.style.transform = `translate(${elX}px, ${elY}px)`;
        }
      }
    }
    for (const npcId in visibleNpcElements) {
      if (!newVisibleNPCs[npcId]) {
        visibleNpcElements[npcId].remove();
        delete visibleNpcElements[npcId];
      }
    }
  }

  function updateHUD() {
    if (!gameState || !gameState.player) return;
    hpDisplay.textContent = `${gameState.player.hp}/${gameState.player.maxHp}`;
    strengthDisplay.textContent = gameState.player.strength;
    xpDisplay.textContent = `${gameState.player.xp}/${gameState.player.xpForNextStrength}`;
    levelDisplay.textContent = gameState.level;
    keyDisplay.textContent = gameState.player.hasKey ? '' : '';
    woodDisplay.textContent = gameState.player.wood;
    stoneDisplay.textContent = gameState.player.stone;
    gemDisplay.textContent = gameState.player.gems;
    herbDisplay.textContent = gameState.player.herbs;
    arrowsDisplay.textContent = gameState.player.inventory.includes('crossbow') ? gameState.player.arrows : '';
    timeDisplay.textContent = gameState.timeOfDay === 'day' ? ' Day' : ' Night';
    const hpElement = document.getElementById('hud-hp');
    if ((gameState.player.hp / gameState.player.maxHp) < 0.25) {
      hpElement.classList.add('low-health-warning');
    } else {
      hpElement.classList.remove('low-health-warning');
    }
    updateWeaponBar();
  }

  function updateWeaponBar() {
    weaponBar.innerHTML = '';
    const availableWeapons = WEAPON_HOTBAR_ORDER.filter(wId => gameState.player.inventory.includes(wId));
    availableWeapons.forEach((weaponId, index) => {
      const weaponData = WEAPONS[weaponId];
      const slot = document.createElement('div');
      slot.className = 'weapon-slot';
      if (weaponId === gameState.player.equippedWeapon) {
        slot.classList.add('active');
      }
      const keyEl = document.createElement('span');
      keyEl.className = 'weapon-key';
      keyEl.textContent = index + 1;
      const emojiEl = document.createElement('span');
      emojiEl.className = 'weapon-emoji';
      emojiEl.textContent = weaponData.emoji;
      slot.appendChild(keyEl);
      slot.appendChild(emojiEl);
      weaponBar.appendChild(slot);
    });
  }

  function updateCell(x, y, newTile) {
    const pathTile = gameState.isUnderworld ? TILE.UW_PATH : TILE.PATH;
    const isEntityTile = OBJECT_DATA[newTile] && ['monster', 'special', 'boss', 'npc'].includes(OBJECT_DATA[newTile].type);
    if (!isEntityTile) {
      gameState.world[y][x] = newTile;
    }
    const cell = visibleCellElements[`cell-${x}-${y}`];
    if (cell) {
      let displayTile = gameState.world[y][x];
      if (gameState.level < 20) {
        if (x === gameState.keyPos.x && y === gameState.keyPos.y && !gameState.player.hasKey) {
          displayTile = TILE.KEY;
        } else if (x === gameState.doorPos.x && y === gameState.doorPos.y) {
          displayTile = TILE.DOOR;
        }
      }
      if (gameState.world[y][x] === TILE.WATER) {
        cell.style.backgroundColor = '#42a5f5';
        displayTile = TILE.EMPTY;
      } else {
        cell.style.backgroundColor = 'transparent';
      }
      const monsterAtPos = gameState.monsters.find((m) => m.x === x && m.y === y && !m.isDying);
      const npcAtPos = gameState.npcs.find((n) => n.x === x && n.y === y);
      if (monsterAtPos || npcAtPos) {
        if (displayTile !== TILE.KEY && displayTile !== TILE.DOOR && displayTile !== TILE.CAGE) {
          displayTile = gameState.world[y][x] === pathTile ? pathTile : TILE.EMPTY;
        }
      }
      cell.textContent = displayTile;
      updateCellClass(cell, displayTile);
    }
  }

  function updateCellClass(cell, tile) {
    cell.className = 'cell';
    if (tile === TILE.PATH) cell.classList.add('path');
    else if (tile === TILE.UW_PATH) cell.classList.add('underworld-path');
    else if (tile === TILE.SHELTER) cell.classList.add('shelter');
    else if ([TILE.WALL_1, TILE.WALL_2, TILE.STONE, TILE.GEM].includes(tile)) cell.classList.add('large');
    else if ([TILE.DECOR_1, TILE.DECOR_2, TILE.DECOR_3, TILE.HERB].includes(tile)) cell.classList.add('small');
  }

  function initRainEffect(dropCount) {
    stopRainEffect();
    audioManager.startAmbiance('ambiance_rain');
    for (let i = 0; i < dropCount; i++) {
      const drop = document.createElement('div');
      drop.className = 'raindrop';
      drop.style.left = `${Math.random() * 110}vw`;
      drop.style.animationDuration = `${0.5 + Math.random() * 0.8}s`;
      drop.style.animationDelay = `${Math.random() * 2}s`;
      drop.style.opacity = Math.random() * 0.6 + 0.3;
      drop.style.transform = `scale(${0.5 + Math.random()})`;
      rainContainer.appendChild(drop);
    }
  }

  function stopRainEffect() {
    rainContainer.innerHTML = '';
  }

  function triggerLightning() {
    audioManager.playSound('effect_thunder');
    lightningFlash.style.opacity = '0.7';
    setTimeout(() => {
      lightningFlash.style.opacity = '0';
    }, 150);
  }

  function handleInteraction(x, y, tile) {
    if (gameState.level === 20) {
      if (gameState.world[y][x] === TILE.CAGE) {
        if (gameState.player.hasUnicornKey) {
          gameWon();
        } else {
          showMessage("The cage is magically sealed. You need a special key!");
        }
      }
      return;
    }
    if (x === gameState.doorPos.x && y === gameState.doorPos.y) {
      if (gameState.player.hasKey) {
        audioManager.playSound('door_open_creak');
        levelUp();
      } else {
        showMessage("The door is locked! You need a key .");
      }
    } else if (x === gameState.keyPos.x && y === gameState.keyPos.y && !gameState.player.hasKey) {
      gameState.player.hasKey = true;
      audioManager.playSound('key_pickup');
      updateCell(x, y, gameState.world[y][x]);
      showMessage("You found the key!  Now find the door !");
      updateHUD();
    } else {
      const item = OBJECT_DATA[tile];
      if (item && item.type === 'food') {
        if (gameState.player.hp < gameState.player.maxHp) {
          gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + item.hpGain);
          updateCell(x, y, TILE.EMPTY);
          updateHUD();
          showPlayerStatusBar();
          audioManager.playSound('item_pickup');
        } else {
          showMessage("You are at full health and don't need food right now.");
        }
      }
    }
  }

  function handleNPCInteraction() {
    const p = gameState.player.pos;
    for (const npc of gameState.npcs) {
      if (Math.abs(p.x - npc.x) <= 1 && Math.abs(p.y - npc.y) <= 1) {
        const data = NPC_DATA[npc.tile];
        if (data) {
          const dialogue = data.getDialogue(npc);
          const options = data.options(npc).map(opt => {
            return {
              text: opt.text,
              action: opt.action === 'close' ? null : opt.action
            };
          });
          showMessage(dialogue, null, options);
          return;
        }
      }
    }
  }

  function gatherResource(resource, cellElement) {
    if (gameState.player.hp <= GATHER_HP_COST) {
      showMessage("You are too weak to gather resources!");
      return;
    }
    if (resource.type === 'tree') {
      audioManager.playSound('tree_chop');
    } else if (resource.type === 'stone') {
      audioManager.playSound('gather_stone');
    } else if (resource.type === 'gem') {
      audioManager.playSound('gather_gem');
    } else if (resource.type === 'herb') {
      audioManager.playSound('gather_herb');
    }
    resource.hits++;
    cellElement.classList.add('shaking');
    setTimeout(() => cellElement.classList.remove('shaking'), 150);
    if (resource.hits >= GATHERING_HITS) {
      let replacementTile = TILE.EMPTY;
      if (resource.type === 'tree') {
        gameState.player.wood += WOOD_PER_TREE;
        showMessage(`+${WOOD_PER_TREE} , -${GATHER_HP_COST} `);
        replacementTile = TILE.DECOR_1;
      } else if (resource.type === 'stone') {
        gameState.player.stone += STONE_PER_ROCK;
        showMessage(`+${STONE_PER_ROCK} , -${GATHER_HP_COST} `);
      } else if (resource.type === 'gem') {
        gameState.player.gems += GEM_PER_ROCK;
        showMessage(`+${GEM_PER_ROCK} , -${GATHER_HP_COST} `);
      } else if (resource.type === 'herb') {
        gameState.player.herbs += HERB_PER_PLANT;
        showMessage(`+${HERB_PER_PLANT} , -${GATHER_HP_COST} `);
      }
      gameState.player.hp -= GATHER_HP_COST;
      updateCell(resource.x, resource.y, replacementTile);
      gameState.resources = gameState.resources.filter((r) => r !== resource);
      updateHUD();
      showPlayerStatusBar();
    }
  }

  function buildShelter() {
    if (gameState.isFighting) return;
    const costs = gameState.levelConfig;
    if (gameState.player.wood < costs.shelterWoodCost) {
      showMessage(`Need ${costs.shelterWoodCost} wood to build a shelter.`);
      return;
    }
    if (gameState.player.hp <= costs.shelterHPCost) {
      showMessage(`Need more than ${costs.shelterHPCost} health to build.`);
      return;
    }
    const p = gameState.player.pos;
    const currentTile = gameState.world[p.y][p.x];
    const pathTile = gameState.isUnderworld ? TILE.UW_PATH : TILE.PATH;
    if (currentTile === TILE.EMPTY || currentTile === pathTile) {
      gameState.player.wood -= costs.shelterWoodCost;
      gameState.player.hp -= costs.shelterHPCost;
      updateCell(p.x, p.y, TILE.SHELTER);
      audioManager.playSound('tree_chop');
      setTimeout(() => audioManager.playSound('tree_chop'), 150);
      setTimeout(() => audioManager.playSound('tree_chop'), 300);
      updateHUD();
      showMessage("You built a shelter! ");
    } else {
      showMessage("You can't build here!");
    }
  }

  function buildStoneWeapon(weaponType) {
    if (gameState.isFighting) return;
    const weaponData = WEAPONS[weaponType];
    if (gameState.player.inventory.includes(weaponType)) {
      showMessage(`You have already crafted a ${weaponData.name}.`);
      return;
    }
    const cost = weaponType === 'sword' ? STONE_SWORD_COST : STONE_SLEDGE_COST;
    if (gameState.player.stone < cost) {
      showMessage(`Need ${cost} stone for the ${weaponData.name}.`);
      return;
    }
    gameState.player.stone -= cost;
    gameState.player.inventory.push(weaponType);
    equipWeapon(weaponType);
    showMessage(`You crafted a ${weaponData.name}! ${weaponData.emoji}`);
  }

  function buildCrossbow() {
    const costs = gameState.levelConfig;
    if (gameState.player.inventory.includes('crossbow')) {
      showMessage(`You have already crafted a Crossbow.`);
      return;
    }
    if (gameState.isFighting) return;
    if (gameState.player.wood < costs.crossbowWoodCost) {
      showMessage(`Need ${costs.crossbowWoodCost} wood to craft a crossbow.`);
      return;
    }
    if (gameState.player.hp <= costs.crossbowHPCost) {
      showMessage(`Need more than ${costs.crossbowHPCost} health to build.`);
      return;
    }
    gameState.player.wood -= costs.crossbowWoodCost;
    gameState.player.hp -= costs.crossbowHPCost;
    gameState.player.inventory.push('crossbow');
    gameState.player.arrows += 50;
    equipWeapon('crossbow');
    showMessage(`You crafted a Crossbow! ${TILE.CROSSBOW} +50 ${TILE.ARROW}`);
  }

  function craftArrows() {
    if (gameState.isFighting) return;
    if (!gameState.player.inventory.includes('crossbow')) {
      showMessage("You need a crossbow to craft arrows.");
      return;
    }
    const cost = ARROW_CRAFTING_COST;
    if (gameState.player.wood < cost) {
      showMessage(`Need ${cost} wood to craft arrows.`);
      return;
    }
    gameState.player.wood -= cost;
    gameState.player.arrows += 50;
    updateHUD();
    showMessage(`You crafted 50 arrows! +50 ${TILE.ARROW}, -${cost} `);
  }

  function craftHealthPotion() {
    if (gameState.isFighting) {
      showMessage("Cannot craft during combat!");
      return;
    }
    const HERB_COST = 5;
    const HEAL_AMOUNT = 50;
    if (gameState.player.herbs < HERB_COST) {
      showMessage(`Need ${HERB_COST} ${TILE.HERB} to craft a health potion.`);
      return;
    }
    if (gameState.player.hp >= gameState.player.maxHp) {
      showMessage("You are already at full health!");
      return;
    }
    gameState.player.herbs -= HERB_COST;
    gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + HEAL_AMOUNT);
    showMessage(`You crafted a potion! +${HEAL_AMOUNT} , -${HERB_COST} `);
    updateHUD();
    showPlayerStatusBar();
  }

  function equipWeapon(weaponId) {
    if (gameState.player.inventory.includes(weaponId)) {
      gameState.player.equippedWeapon = weaponId;
      const weaponData = WEAPONS[weaponId];
      showMessage(`Switched to ${weaponData.name} ${weaponData.emoji}`);
      updateHUD();
    }
  }

  function startFight(monster) {
    if (gameState.isFighting) return;
    gameState.isFighting = true;
    gameState.activeFighter = monster;
    const monsterEl = visibleMonsterElements[monster.id];
    if (monsterEl) {
      createHealthBar(monsterEl, monster.currentHp, monster.baseHp, 'monster');
      monsterEl.classList.add('fighting-monster');
    }
    createHealthBar(playerElement, gameState.player.hp, gameState.player.maxHp, 'player');
    gameState.monsterAttackInterval = setInterval(() => {
      if (!gameState.isFighting || !gameState.activeFighter) return;
      const monsterDamage = gameState.activeFighter.currentStrength + Math.floor(Math.random() * 3) - 1;
      gameState.player.hp -= Math.max(0, monsterDamage);
      if (monsterDamage > 0) {
        audioManager.playSound('player_take_damage');
      }
      updateHUD();
      updateHealthBar(playerElement, gameState.player.hp, gameState.player.maxHp);
      if (gameState.player.hp <= 0) {
        endFight('lose');
      }
    }, MONSTER_ATTACK_SPEED);
  }

  function endFight(outcome) {
    if (!gameState.isFighting) return;
    const monster = gameState.activeFighter;
    if (monster) {
      const monsterEl = visibleMonsterElements[monster.id];
      if (monsterEl) {
        const healthBar = monsterEl.querySelector('.health-bar-container');
        if (healthBar) healthBar.remove();
        monsterEl.classList.remove('fighting-monster');
      }
    }
    const playerHealthBar = playerElement.querySelector('.health-bar-container');
    if (playerHealthBar) playerHealthBar.remove();
    clearInterval(gameState.monsterAttackInterval);
    gameState.monsterAttackInterval = null;
    gameState.isFighting = false;
    gameState.activeFighter = null;
    if (outcome === 'win' && monster) {
      killMonster(monster);
    } else if (outcome === 'lose') {
      gameState.player.hp = 0;
      gameOver();
    }
    updateHUD();
  }

  function killMonster(monster) {
    audioManager.playSound('monster_die_xp');
    monster.isDying = true;
    const reward = OBJECT_DATA[monster.tile].xpReward || 0;
    showMessage(`Defeated ${monster.tile}! +${reward} XP `);
    if (monster.isBoss) {
      showMessage("The boss dropped some food! ");
      gameState.world[monster.y][monster.x] = TILE.FOOD_2;
      if (gameState.level === 20) {
        gameState.player.hasUnicornKey = true;
        showMessage("The Dragon dropped a strange key!  It must be for the Unicorn's cage!");
      }
    }
    gameState.player.xp += reward;
    checkIfStrengthIncreases();
    updateHUD();
    const monsterEl = visibleMonsterElements[monster.id];
    if (monsterEl) {
      const healthBar = monsterEl.querySelector('.health-bar-container');
      if (healthBar) healthBar.remove();
      monsterEl.classList.remove('fighting-monster');
      const sprite = monsterEl.querySelector('.monster-sprite');
      if (sprite) sprite.textContent = TILE.DEAD;
      monsterEl.style.transition = 'opacity 2s ease-out';
      monsterEl.style.opacity = '0';
      setTimeout(() => {
        monsterEl.remove();
        delete visibleMonsterElements[monster.id];
        gameState.monsters = gameState.monsters.filter((m) => m.id !== monster.id);
        updateVisibleCells();
      }, 2000);
    } else {
      gameState.monsters = gameState.monsters.filter((m) => m.id !== monster.id);
      updateVisibleCells();
    }
  }

  function checkIfStrengthIncreases() {
    while (gameState.player.xp >= gameState.player.xpForNextStrength) {
      gameState.player.xp -= gameState.player.xpForNextStrength;
      gameState.player.strength++;
      gameState.player.xpForNextStrength = Math.floor(gameState.player.xpForNextStrength * 1.5);
      showMessage(` Strength increased to ${gameState.player.strength}! `, null);
      updateHUD();
    }
  }

  function shootCrossbow(targetMapX, targetMapY) {
    if (gameState.player.arrows <= 0) {
      showMessage("You're out of arrows!");
      return;
    }
    audioManager.playSound('arrow_shoot_swoosh');
    const pPos = gameState.player.pixelPos;
    const dx = targetMapX - pPos.x;
    const dy = targetMapY - pPos.y;
    if (Math.hypot(dx, dy) < cellSize / 2) return;
    gameState.player.arrows--;
    updateHUD();
    const len = Math.hypot(dx, dy);
    const dirX = dx / len;
    const dirY = dy / len;
    const arrow = document.createElement('div');
    arrow.className = 'arrow';
    arrow.textContent = TILE.ARROW;
    const angle = (Math.atan2(dirY, dirX) * 180) / Math.PI;
    arrow.style.left = `${pPos.x - cellSize / 4}px`;
    arrow.style.top = `${pPos.y - cellSize / 4}px`;
    arrow.style.transform = `rotate(${angle}deg)`;
    mapGrid.appendChild(arrow);
    gameState.activeProjectiles.push({
      el: arrow,
      x: pPos.x,
      y: pPos.y,
      dx: dirX,
      dy: dirY,
      speed: 800,
      distanceTraveled: 0,
      maxDistance: 15 * cellSize,
    });
  }

  function updateProjectiles(deltaTime) {
    for (let i = gameState.activeProjectiles.length - 1; i >= 0; i--) {
      const p = gameState.activeProjectiles[i];
      const moveDist = p.speed * deltaTime;
      p.x += p.dx * moveDist;
      p.y += p.dy * moveDist;
      p.distanceTraveled += moveDist;
      p.el.style.left = `${p.x - cellSize / 4}px`;
      p.el.style.top = `${p.y - cellSize / 4}px`;
      let hit = false;
      const gridX = Math.floor(p.x / cellSize);
      const gridY = Math.floor(p.y / cellSize);
      const monster = gameState.monsters.find((m) => !m.isDying && m.x === gridX && m.y === gridY);
      if (monster && monster.tile !== TILE.SWAN) {
        hit = true;
        audioManager.playSound('arrow_hit_thud');
        let damage = CROSSBOW_BASE_DAMAGE + Math.floor(gameState.player.strength / CROSSBOW_STRENGTH_DAMAGE_FACTOR);
        if (monster.isBoss) {
          damage = Math.max(1, Math.floor(damage / 10));
        }
        monster.currentHp -= damage;
        monster.isAggroed = true;
        const monsterEl = visibleMonsterElements[monster.id];
        if (monsterEl) {
          if (!monsterEl.querySelector('.health-bar-container')) {
            createHealthBar(monsterEl, monster.currentHp, monster.baseHp, 'monster');
          }
          updateHealthBar(monsterEl, monster.currentHp, monster.baseHp);
        }
        if (monster.currentHp <= 0) {
          if (gameState.isFighting && gameState.activeFighter.id === monster.id) {
            endFight('win');
          } else if (!gameState.isFighting) {
            killMonster(monster);
          }
        }
      }
      if (isTileBlocking(gridX, gridY) || p.distanceTraveled >= p.maxDistance) {
        hit = true;
      }
      if (hit) {
        p.el.remove();
        gameState.activeProjectiles.splice(i, 1);
      }
    }
  }

  function createHealthBar(parent, current, max, type) {
    const existingBar = parent.querySelector('.health-bar-container');
    if (existingBar) existingBar.remove();
    const container = document.createElement('div');
    container.className = 'health-bar-container';
    const inner = document.createElement('div');
    inner.className = `health-bar-inner ${type}`;
    inner.style.width = `${Math.max(0, (current / max) * 100)}%`;
    container.appendChild(inner);
    parent.appendChild(container);
  }

  function updateHealthBar(barParent, current, max) {
    if (!barParent) return;
    const innerBar = barParent.querySelector('.health-bar-inner');
    if (innerBar) {
      innerBar.style.width = `${Math.max(0, (current / max) * 100)}%`;
    }
  }

  function showPlayerStatusBar() {
    if (gameState.playerStatusBar) {
      gameState.playerStatusBar.remove();
    }
    const container = document.createElement('div');
    container.className = 'status-bar-container';
    const inner = document.createElement('div');
    inner.className = 'status-bar-inner';
    const hpPercent = (gameState.player.hp / gameState.player.maxHp) * 100;
    inner.style.width = `${Math.max(0, hpPercent)}%`;
    container.appendChild(inner);
    playerElement.appendChild(container);
    gameState.playerStatusBar = container;
    setTimeout(() => {
      if (gameState.playerStatusBar === container) container.classList.add('fading-out');
    }, 2000);
    setTimeout(() => {
      if (gameState.playerStatusBar === container) {
        container.remove();
        gameState.playerStatusBar = null;
      }
    }, 2500);
  }

  function checkAggro() {
    if (gameState.isFighting) return;
    const pPos = gameState.player.pos;
    for (const monster of gameState.monsters) {
      if (monster.isDying || monster.tile === TILE.GHOST || monster.tile === TILE.SWAN) continue;
      const distance = Math.hypot(pPos.x - monster.x, pPos.y - monster.y);
      if (monster.isBoss && distance < BOSS_AGGRO_RANGE) {
        startFight(monster);
        return;
      }
      if (!monster.isBoss && distance < 2) {
        startFight(monster);
        return;
      }
    }
    const swan = gameState.monsters.find(m => m.tile === TILE.SWAN);
    if (swan && gameState.player.hp < gameState.player.maxHp) {
      const distanceToSwan = Math.hypot(pPos.x - swan.x, pPos.y - swan.y);
      if (distanceToSwan < 1.5) {
        gameState.player.hp = gameState.player.maxHp;
        audioManager.playSound('swan_heal');
        showMessage("The magic swan  heals you! You are at full health .");
        updateHUD();
        showPlayerStatusBar();
      }
    }
  }

  function updateEntityPixelPositions(deltaTime) {
    const entities = [...gameState.monsters, ...gameState.npcs];
    for (const entity of entities) {
      if (entity.isDying) continue;
      if (entity.tile === TILE.GHOST && entity.isHunting) {
        const playerPixelPos = gameState.player.pixelPos;
        const dx = playerPixelPos.x - entity.pixelPos.x;
        const dy = playerPixelPos.y - entity.pixelPos.y;
        const dist = Math.hypot(dx, dy);
        if (dist > cellSize) {
          const dirX = dx / dist;
          const dirY = dy / dist;
          const moveAmount = entity.speed * deltaTime;
          entity.pixelPos.x += dirX * moveAmount;
          entity.pixelPos.y += dirY * moveAmount;
          entity.x = Math.floor(entity.pixelPos.x / cellSize);
          entity.y = Math.floor(entity.pixelPos.y / cellSize);
        }
        continue;
      }
      const dx = entity.targetPixelPos.x - entity.pixelPos.x;
      const dy = entity.targetPixelPos.y - entity.pixelPos.y;
      const dist = Math.hypot(dx, dy);
      if (dist < 1) continue;
      const moveAmount = entity.speed * deltaTime;
      if (dist < moveAmount) {
        entity.pixelPos.x = entity.targetPixelPos.x;
        entity.pixelPos.y = entity.targetPixelPos.y;
      } else {
        entity.pixelPos.x += (dx / dist) * moveAmount;
        entity.pixelPos.y += (dy / dist) * moveAmount;
      }
    }
  }

  function moveEntities() {
    const playerInShelterAtNight = gameState.timeOfDay === 'night' && gameState.world[gameState.player.pos.y][gameState.player.pos.x] === TILE.SHELTER;
    const ghostsToRemove = [];
    const allEntities = [...gameState.monsters, ...gameState.npcs];
    allEntities.forEach((entity) => {
      if (entity.isDying) return;
      if (entity.tile === TILE.SWAN) {
        if (Math.random() > 0.6) {
          const validMoves = [];
          [
            [0, -1],
            [0, 1],
            [-1, 0],
            [1, 0]
          ].forEach(move => {
            const newX = entity.x + move[0];
            const newY = entity.y + move[1];
            if (gameState.world[newY] && gameState.world[newY][newX] === TILE.WATER) {
              validMoves.push(move);
            }
          });
          if (validMoves.length > 0) {
            const chosenMove = validMoves[Math.floor(Math.random() * validMoves.length)];
            entity.x += chosenMove[0];
            entity.y += chosenMove[1];
            entity.targetPixelPos = {
              x: entity.x * cellSize + cellSize / 2,
              y: entity.y * cellSize + cellSize / 2
            };
          }
        }
        return;
      }
      if (entity.tile === TILE.GHOST) {
        entity.isHunting = true;
        const distanceToPlayer = Math.hypot(gameState.player.pos.x - entity.x, gameState.player.pos.y - entity.y);
        if (distanceToPlayer < 1.5 && !playerInShelterAtNight) {
          const damage = 15 + Math.floor(Math.random() * 10);
          let stolenItems = [];
          if (gameState.player.hasKey) {
            gameState.player.hasKey = false;
            stolenItems.push(TILE.KEY);
          }
          if (gameState.player.inventory.includes('crossbow')) {
            gameState.player.inventory = gameState.player.inventory.filter(w => w !== 'crossbow');
            if (gameState.player.arrows > 0) {
              stolenItems.push(`${gameState.player.arrows} ${TILE.ARROW}`);
              gameState.player.arrows = 0;
            }
            stolenItems.push(TILE.CROSSBOW);
          }
          if (gameState.player.wood > 0) {
            stolenItems.push(`${gameState.player.wood} `);
            gameState.player.wood = 0;
          }
          if (stolenItems.includes(TILE.KEY) && gameState.level < 20) {
            const newKeyPos = getRandomEmptyPosition(TILE.EMPTY, [gameState.player.pos], 10);
            if (newKeyPos) {
              gameState.keyPos = newKeyPos;
              updateCell(newKeyPos.x, newKeyPos.y, TILE.KEY);
            }
          }
          gameState.player.hp = Math.max(0, gameState.player.hp - damage);
          updateHUD();
          let message = ` A ghost attacked! You lost ${damage} .`;
          if (stolenItems.length > 0) {
            message += ` It stole: ${stolenItems.join(', ')}!`;
          }
          showMessage(message);
          ghostsToRemove.push(entity.id);
          const entityEl = visibleMonsterElements[entity.id];
          if (entityEl) entityEl.remove();
          delete visibleMonsterElements[entity.id];
          if (gameState.player.hp <= 0) gameOver();
          return;
        }
        return;
      }
      if (playerInShelterAtNight || OBJECT_DATA[entity.tile].type === 'special') return;
      const atTarget = Math.hypot(entity.pixelPos.x - entity.targetPixelPos.x, entity.pixelPos.y - entity.targetPixelPos.y) < 1;
      if (!atTarget) return;
      let move = [0, 0];
      const pPos = gameState.player.pos;
      let targetPos = null;
      if (entity.isBoss) {
        const distanceToPlayer = Math.hypot(pPos.x - entity.x, pPos.y - entity.y);
        if (distanceToPlayer < BOSS_CHASE_RANGE) {
          targetPos = pPos;
        } else if (entity.x !== entity.homePos.x || entity.y !== entity.homePos.y) {
          targetPos = entity.homePos;
        }
      } else if (entity.isAggroed) {
        targetPos = pPos;
      }
      if (targetPos) {
        const dx = targetPos.x - entity.x;
        const dy = targetPos.y - entity.y;
        if (Math.abs(dx) > Math.abs(dy)) {
          move[0] = Math.sign(dx);
        } else if (dy !== 0) {
          move[1] = Math.sign(dy);
        } else if (dx !== 0) {
          move[0] = Math.sign(dx);
        }
      } else {
        if (Math.random() > 0.4) return;
        const options = [
          [0, -1],
          [0, 1],
          [-1, 0],
          [1, 0]
        ];
        move = options[Math.floor(Math.random() * 4)];
      }
      const newX = entity.x + move[0];
      const newY = entity.y + move[1];
      const canMove = !isTileBlocking(newX, newY);
      if ((move[0] !== 0 || move[1] !== 0) && canMove) {
        const oldX = entity.x;
        const oldY = entity.y;
        entity.x = newX;
        entity.y = newY;
        entity.targetPixelPos = {
          x: newX * cellSize + cellSize / 2,
          y: newY * cellSize + cellSize / 2
        };
        updateVisibleCells();
      }
    });
    if (ghostsToRemove.length > 0) {
      gameState.monsters = gameState.monsters.filter((m) => !ghostsToRemove.includes(m.id));
      updateVisibleCells();
    }
    checkAggro();
  }

  function mainGameLoop(timestamp) {
    if (gameState.isGameOver) {
      cancelAnimationFrame(mainGameLoopId);
      return;
    }
    const deltaTime = Math.min((timestamp - lastFrameTime) / 1000, 0.1);
    lastFrameTime = timestamp;
    processPlayerInputAndMove(deltaTime);
    updateEntityPixelPositions(deltaTime);
    updateProjectiles(deltaTime);
    render();
    mainGameLoopId = requestAnimationFrame(mainGameLoop);
  }

  function gameTick() {
    if (gameState.isGameOver || gameState.isFighting) return;
    updateTime();
    moveEntities();
    if (gameState.time % 10 === 0) {
      respawnFoodIfNeeded();
    }
    if (gameState.isUnderworld && Math.random() < 0.05) {
      triggerLightning();
    }
  }

  function processPlayerInputAndMove(deltaTime) {
    if (gameState.isFighting) {
      playerElement.classList.remove('is-walking');
      return;
    }
    let dx = 0;
    let dy = 0;
    if (keysPressed['w'] || keysPressed['arrowup']) dy = -1;
    if (keysPressed['s'] || keysPressed['arrowdown']) dy = 1;
    if (keysPressed['a'] || keysPressed['arrowleft']) dx = -1;
    if (keysPressed['d'] || keysPressed['arrowright']) dx = 1;
    if (dx === 0 && dy === 0) {
      playerElement.classList.remove('is-walking');
      return;
    }
    playerElement.classList.add('is-walking');
    audioManager.playSoundThrottled('player_walk', 300);
    const length = Math.sqrt(dx * dx + dy * dy);
    if (length > 0) {
      dx /= length;
      dy /= length;
    }
    const moveAmount = PLAYER_SPEED * deltaTime;
    const newPixelX = gameState.player.pixelPos.x + dx * moveAmount;
    const newPixelY = gameState.player.pixelPos.y + dy * moveAmount;
    const playerHalfWidth = cellSize / 4;
    const targetXGrid = Math.floor((newPixelX + Math.sign(dx) * playerHalfWidth) / cellSize);
    const currentYGridForXCheck = Math.floor(gameState.player.pixelPos.y / cellSize);
    if (!isTileBlocking(targetXGrid, currentYGridForXCheck)) {
      gameState.player.pixelPos.x = newPixelX;
    }
    const targetYGrid = Math.floor((newPixelY + Math.sign(dy) * playerHalfWidth) / cellSize);
    const currentXGridForYCheck = Math.floor(gameState.player.pixelPos.x / cellSize);
    if (!isTileBlocking(currentXGridForYCheck, targetYGrid)) {
      gameState.player.pixelPos.y = newPixelY;
    }
    const oldGridX = gameState.player.pos.x;
    const oldGridY = gameState.player.pos.y;
    const newGridX = Math.floor(gameState.player.pixelPos.x / cellSize);
    const newGridY = Math.floor(gameState.player.pixelPos.y / cellSize);
    if (newGridX !== oldGridX || newGridY !== oldGridY) {
      gameState.player.pos.x = newGridX;
      gameState.player.pos.y = newGridY;
      updateVisibleCells();
      const targetTile = gameState.world[newGridY][newGridX];
      handleInteraction(newGridX, newGridY, targetTile);
      checkAggro();
    }
  }

  function isTileBlocking(x, y) {
    if (x < 0 || x >= WORLD_SIZE.cols || y < 0 || y >= WORLD_SIZE.rows) return true;
    const targetTile = gameState.world[y][x];
    const blockingTiles = [TILE.WALL_1, TILE.WALL_2, TILE.STONE, TILE.WATER, TILE.GEM, TILE.CAGE];
    if (blockingTiles.includes(targetTile)) return true;
    if (gameState.monsters.some((m) => !m.isDying && m.tile !== TILE.GHOST && m.tile !== TILE.SWAN && m.x === x && m.y === y)) return true;
    if (gameState.npcs.some((n) => n.x === x && n.y === y)) return true;
    return false;
  }

  function updateTime() {
    if (gameState.level === 20) return;
    gameState.time++;
    const cycleDuration = DAY_DURATION + NIGHT_DURATION;
    const timeInCycle = gameState.time % cycleDuration;
    const wasDay = gameState.timeOfDay === 'day';
    if (wasDay && timeInCycle >= DAY_DURATION) {
      gameState.timeOfDay = 'night';
      nightOverlay.classList.add('is-night');
      audioManager.stopAmbiance('wind_ambiance');
      audioManager.stopBirdSounds();
      if (!gameState.isUnderworld) {
        audioManager.startNightSounds();
      }
      gameState.monsters.forEach((m) => {
        m.currentStrength = Math.floor(m.baseStrength * NIGHT_STRENGTH_BONUS);
      });
      setTimeout(spawnGhosts, 10000);
    } else if (!wasDay && timeInCycle < DAY_DURATION) {
      gameState.timeOfDay = 'day';
      nightOverlay.classList.remove('is-night');
      audioManager.stopNightSounds();
      if (!gameState.isUnderworld) {
        audioManager.startAmbiance('wind_ambiance');
        audioManager.startBirdSounds();
      }
      gameState.monsters.forEach((m) => {
        m.currentStrength = m.baseStrength;
      });
      despawnGhosts();
    }
    updateHUD();
  }

  function spawnGhosts() {
    if (gameState.isFighting) return;
    audioManager.playSound('ghost_spawn');
    const ghostCount = 2 + gameState.level;
    placeMonsters(TILE.GHOST, ghostCount);
    showMessage("A sinister presence is felt... ");
  }

  function despawnGhosts() {
    gameState.monsters.forEach((monster) => {
      if (monster.tile === TILE.GHOST) {
        const monsterEl = visibleMonsterElements[monster.id];
        if (monsterEl) {
          monsterEl.remove();
          delete visibleMonsterElements[monster.id];
        }
      }
    });
    gameState.monsters = gameState.monsters.filter((monster) => monster.tile !== TILE.GHOST);
  }

  function respawnFoodIfNeeded() {
    let foodCount = 0;
    const foodTiles = [TILE.FOOD_1, TILE.FOOD_2];
    for (let y = 0; y < WORLD_SIZE.rows; y++) {
      for (let x = 0; x < WORLD_SIZE.cols; x++) {
        if (foodTiles.includes(gameState.world[y][x])) {
          foodCount++;
        }
      }
    }
    if (foodCount < MIN_FOOD_COUNT) {
      placeObjectsInBiome(TILE.FOOD_1, Math.ceil(FOOD_RESPAWN_AMOUNT * 0.7), TILE.EMPTY, true);
      placeObjectsInBiome(TILE.FOOD_2, Math.floor(FOOD_RESPAWN_AMOUNT * 0.3), TILE.EMPTY, true);
    }
  }

  function jumpToLevel(level) {
    closeModal();
    messageQueue = [];
    gameState.level = level - 1;
    setupNewGame();
  }

  window.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if (isDisplayingMessage) {
      if (key === 'escape' || key === 'enter') {
        if (!messageBox.classList.contains('has-options') || gameState.isGameOver) {
          (messageButton.onclick || closeModal)();
        }
      }
      if (key === 'q') {
        e.preventDefault();
        const code = prompt('Enter code to switch levels:');
        if (code === '1234') {
          const levelInput = prompt('Which level do you want to jump to?', gameState.level);
          const targetLevel = parseInt(levelInput);
          if (!isNaN(targetLevel) && targetLevel > 0) {
            jumpToLevel(targetLevel);
          } else if (levelInput) {
            alert('Invalid level. Enter a number greater than 0.');
          }
        } else if (code) {
          alert('Incorrect code.');
        }
      }
    } else {
      keysPressed[key] = true;
      if (['1', '2', '3', '4'].includes(key)) {
        e.preventDefault();
        const hotbar = WEAPON_HOTBAR_ORDER.filter(wId => gameState.player.inventory.includes(wId));
        const weaponIndex = parseInt(key) - 1;
        if (hotbar[weaponIndex]) {
          equipWeapon(hotbar[weaponIndex]);
        }
      } else if (key === 'b') {
        e.preventDefault();
        buildShelter();
      } else if (key === 'c') {
        e.preventDefault();
        buildCrossbow();
      } else if (key === 'p') {
        e.preventDefault();
        craftArrows();
      } else if (key === 'v') {
        e.preventDefault();
        buildStoneWeapon('sword');
      } else if (key === 'h') {
        e.preventDefault();
        buildStoneWeapon('sledge');
      } else if (key === 'm') {
        e.preventDefault();
        craftHealthPotion();
      } else if (key === 'e') {
        e.preventDefault();
        handleNPCInteraction();
      }
    }
  });

  window.addEventListener('keyup', (e) => {
    keysPressed[e.key.toLowerCase()] = false;
  });

  window.addEventListener('resize', () => {
    if (!gameState || !mapGrid || !gameState.player || !gameState.player.pixelPos) {
      return;
    }
    cellSize = (8 * Math.min(window.innerWidth, window.innerHeight)) / 100;
    gameState.player.pixelPos = {
      x: gameState.player.pos.x * cellSize + cellSize / 2,
      y: gameState.player.pos.y * cellSize + cellSize / 2
    };
    const allEntities = [...(gameState.monsters || []), ...(gameState.npcs || [])];
    allEntities.forEach(entity => {
      entity.pixelPos = {
        x: entity.x * cellSize + cellSize / 2,
        y: entity.y * cellSize + cellSize / 2
      };
      entity.targetPixelPos = {
        ...entity.pixelPos
      };
    });
    if (gameState.activeProjectiles) {
      gameState.activeProjectiles.forEach(p => p.el.remove());
      gameState.activeProjectiles = [];
    }
    mapGrid.innerHTML = '';
    visibleCellElements = {};
    visibleMonsterElements = {};
    visibleNpcElements = {};
    updateVisibleCells(true);
    render();
  });

  gameWorld.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    const equipped = WEAPONS[gameState.player.equippedWeapon];
    if (equipped && equipped.type === 'ranged' && !gameState.isFighting && !gameState.isGameOver) {
      const worldRect = gameWorld.getBoundingClientRect();
      const mapTransform = new DOMMatrix(getComputedStyle(mapGrid).transform);
      const clickX = e.clientX - worldRect.left - mapTransform.e;
      const clickY = e.clientY - worldRect.top - mapTransform.f;
      shootCrossbow(clickX, clickY);
    }
  });

  saveGameButton.addEventListener('click', saveGame);
  document.getElementById('export-btn').addEventListener('click', exportSaveFile);
  document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-input').click());
  document.getElementById('import-input').addEventListener('change', importSaveFile);
  howToPlayButton.addEventListener('click', showHowToPlay);

  if (!loadGame()) {
    setupNewGame();
  }
  showHowToPlay();

  function forceInitialDraw() {
    if (!gameState || !gameState.player || gameState.isGameOver || !mainGameLoopId) {
      setTimeout(forceInitialDraw, 50);
      return;
    }
    const gameWidth = gameContainer.clientWidth;
    if (gameWidth > 0) {
      console.log("Layout complete. Simulating key press to draw map...");
      cellSize = (8 * Math.min(window.innerWidth, window.innerHeight)) / 100;
      keysPressed['d'] = true;
      setTimeout(() => {
        keysPressed['d'] = false;
      }, 50);
    } else {
      setTimeout(forceInitialDraw, 50);
    }
  }

  document.body.addEventListener('click', () => audioManager.init(), {
    once: true
  });
  document.body.addEventListener('keydown', () => audioManager.init(), {
    once: true
  });

  forceInitialDraw();
});

</script>
  </body>
</html>