<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo Board Game</title>
<style>

:root {
  --board-size: 94vmin;
  --green: #009e00;
  --blue: #0072b5;
  --red: #e4001b;
  --yellow: #ffed00;
  --white: #ffffff;
  --dark-bg: #303030;
  --light-text: #f0f0f0;
  --highlight-color: #00ffff;
}

body {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  gap: 20px;
  height: 100vh;
  margin: 0;
  background-color: var(--dark-bg);
  font-family: sans-serif;
  color: var(--light-text);
  padding-top: 6px;
  padding-bottom: 6px;
  box-sizing: border-box;
}

#game-container {
  display: flex;
  align-items: center;
  gap: 40px;
  position: relative;
}

svg {
  width: var(--board-size);
  height: var(--board-size);
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
  border-radius: 12px;
  box-shadow: 2px 2px 4px 2px rgba(0, 0, 0, 0.75);
}

#controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  min-width: 300px;
  background-color: #000000;
  padding: 20px;
  border-radius: 12px;
}

#dice {
  width: 80px;
  height: 80px;
  border: 2px solid var(--light-text);
  border-radius: 10px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 48px;
  font-weight: bold;
  transition: border-color 0.3s;
}

button {
  width: 180px;
  padding: 12px 24px;
  font-size: 18px;
  cursor: pointer;
  border-radius: 8px;
  border: none;
  background-color: var(--blue);
  color: var(--white);
  transition: background-color 0.3s;
}

button:disabled {
  background-color: #555;
  cursor: not-allowed;
}

button:not(:disabled):hover {
  background-color: #008fdd;
}

#autopilot-button {
  background-color: #5a5a5a;
  width: 180px;
}

#autopilot-button.active {
  background-color: var(--green);
  color: var(--white);
}

#message-box {
  min-height: 20px;
  text-align: center;
  font-size: 0.8em;
  font-weight: bold;
}

.shape {
  stroke: #000000;
  stroke-width: 0.5;
}

.pawn {
  stroke: #000000;
  stroke-width: 0.5;
  cursor: pointer;
  transition: transform 0.4s ease-in-out, r 0.2s ease-in-out;
}

.pawn.green {
  fill: #009e00;
}

.pawn.blue {
  fill: #0072b5;
}

.pawn.red {
  fill: #e4001b;
}

.pawn.yellow {
  fill: #ffed00;
}

@keyframes glow {
  0% {
    stroke: var(--highlight-color);
    stroke-width: 1.5;
  }

  50% {
    stroke: var(--white);
    stroke-width: 2.5;
  }

  100% {
    stroke: var(--highlight-color);
    stroke-width: 1.5;
  }
}

.pawn.movable {
  animation: glow 1.2s infinite;
}

@keyframes explode {
  0% {
    transform: scale(1);
    opacity: 1;
  }

  100% {
    transform: scale(3.5) rotate(75deg);
    opacity: 0;
  }
}

.pawn.finished-animation {
  animation: explode 0.5s ease-out forwards;
}

#winner-display {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  justify-content: center;
  align-items: center;
  font-size: 10vmin;
  font-weight: bold;
  color: white;
  text-shadow: 0 0 15px black, 0 0 10px black;
  z-index: 1000;
  pointer-events: none;
  opacity: 0;
}

@keyframes fadeInOut {
  0% {
    opacity: 0;
    transform: scale(0.8);
  }

  20% {
    opacity: 1;
    transform: scale(1);
  }

  80% {
    opacity: 1;
    transform: scale(1);
  }

  100% {
    opacity: 0;
    transform: scale(0.8);
  }
}

.show-message {
  display: flex !important;
  animation: fadeInOut 2.5s ease-in-out forwards;
}

#game-start-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.95);
  z-index: 2000;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  color: var(--light-text);
  text-align: center;
  gap: 20px;
}

#game-start-overlay h1 {
  font-size: 6.6vmin;
  margin-bottom: 0;
  color: var(--highlight-color);
  text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
}

#game-start-overlay p {
  font-size: 2vmin;
  max-width: 80%;
  margin: 0;
}

#game-start-overlay button {
  padding: 15px 30px;
  font-size: 2.3vmin;
  background-color: var(--green);
  border: 2px solid var(--white);
  color: var(--white);
  cursor: pointer;
  border-radius: 10px;
  transition: background-color 0.3s ease, border-color 0.3s ease;
}

#game-start-overlay button:hover {
  background-color: #00be00;
  border-color: var(--highlight-color);
}

</style>
  </head>
  <body>
    <div id="game-start-overlay">
      <h1>Ludo Board Game</h1>
      <p>&copy; Johnny Heggelund</p>
      <p>Click "Start Game" to roll the dice and determine who starts first!</p>
      <button id="start-game-button">Start Game</button>
    </div>
    <div id="game-container">
      <div id="winner-display"></div>
      <div id="controls">
        <div id="dice">?</div>
        <button id="roll-button">Roll the dice</button>
        <button id="autopilot-button">Autopilot</button>
        <div id="message-box">Welcome! Green player starts.</div>
      </div>
      <svg viewBox="0 0 150 150" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <style>
            .green-bg {
              fill: #009e00;
            }

            .blue-bg {
              fill: #0072b5;
            }

            .red-bg {
              fill: #e4001b;
            }

            .yellow-bg {
              fill: #ffed00;
            }

            .white-bg {
              fill: #ffffff;
            }
          </style>
        </defs>
        <g id="bases">
          <rect class="white-bg shape" x="0" y="0" width="150" height="150" />
          <rect class="green-bg" x="0" y="0" width="60" height="60" />
          <rect class="blue-bg" x="90" y="0" width="60" height="60" />
          <rect class="yellow-bg" x="0" y="90" width="60" height="60" />
          <rect class="red-bg" x="90" y="90" width="60" height="60" />
        </g>
        <g id="yards">
          <rect class="white-bg shape" x="10" y="10" width="40" height="40" />
          <rect class="white-bg shape" x="100" y="10" width="40" height="40" />
          <rect class="white-bg shape" x="10" y="100" width="40" height="40" />
          <rect class="white-bg shape" x="100" y="100" width="40" height="40" />
        </g>
        <g id="game-path">
          <rect class="white-bg shape" x="60" y="0" width="10" height="10" />
          <rect class="white-bg shape" x="60" y="10" width="10" height="10" />
          <rect class="white-bg shape" x="60" y="20" width="10" height="10" />
          <rect class="white-bg shape" x="60" y="30" width="10" height="10" />
          <rect class="white-bg shape" x="60" y="40" width="10" height="10" />
          <rect class="white-bg shape" x="60" y="50" width="10" height="10" />
          <rect class="white-bg shape" x="80" y="0" width="10" height="10" />
          <rect class="blue-bg shape" x="80" y="10" width="10" height="10" />
          <rect class="white-bg shape" x="80" y="20" width="10" height="10" />
          <rect class="white-bg shape" x="80" y="30" width="10" height="10" />
          <rect class="white-bg shape" x="80" y="40" width="10" height="10" />
          <rect class="white-bg shape" x="80" y="50" width="10" height="10" />
          <rect class="white-bg shape" x="90" y="60" width="10" height="10" />
          <rect class="white-bg shape" x="100" y="60" width="10" height="10" />
          <rect class="white-bg shape" x="110" y="60" width="10" height="10" />
          <rect class="white-bg shape" x="120" y="60" width="10" height="10" />
          <rect class="white-bg shape" x="130" y="60" width="10" height="10" />
          <rect class="white-bg shape" x="140" y="60" width="10" height="10" />
          <rect class="white-bg shape" x="90" y="80" width="10" height="10" />
          <rect class="white-bg shape" x="100" y="80" width="10" height="10" />
          <rect class="white-bg shape" x="110" y="80" width="10" height="10" />
          <rect class="white-bg shape" x="120" y="80" width="10" height="10" />
          <rect class="red-bg shape" x="130" y="80" width="10" height="10" />
          <rect class="white-bg shape" x="140" y="80" width="10" height="10" />
          <rect class="white-bg shape" x="60" y="90" width="10" height="10" />
          <rect class="white-bg shape" x="60" y="100" width="10" height="10" />
          <rect class="white-bg shape" x="60" y="110" width="10" height="10" />
          <rect class="white-bg shape" x="60" y="120" width="10" height="10" />
          <rect class="yellow-bg shape" x="60" y="130" width="10" height="10" />
          <rect class="white-bg shape" x="60" y="140" width="10" height="10" />
          <rect class="white-bg shape" x="80" y="90" width="10" height="10" />
          <rect class="white-bg shape" x="80" y="100" width="10" height="10" />
          <rect class="white-bg shape" x="80" y="110" width="10" height="10" />
          <rect class="white-bg shape" x="80" y="120" width="10" height="10" />
          <rect class="white-bg shape" x="80" y="130" width="10" height="10" />
          <rect class="white-bg shape" x="80" y="140" width="10" height="10" />
          <rect class="white-bg shape" x="0" y="60" width="10" height="10" />
          <rect class="green-bg shape" x="10" y="60" width="10" height="10" />
          <rect class="white-bg shape" x="20" y="60" width="10" height="10" />
          <rect class="white-bg shape" x="30" y="60" width="10" height="10" />
          <rect class="white-bg shape" x="40" y="60" width="10" height="10" />
          <rect class="white-bg shape" x="50" y="60" width="10" height="10" />
          <rect class="white-bg shape" x="0" y="80" width="10" height="10" />
          <rect class="white-bg shape" x="10" y="80" width="10" height="10" />
          <rect class="white-bg shape" x="20" y="80" width="10" height="10" />
          <rect class="white-bg shape" x="30" y="80" width="10" height="10" />
          <rect class="white-bg shape" x="40" y="80" width="10" height="10" />
          <rect class="white-bg shape" x="50" y="80" width="10" height="10" />
        </g>
        <g id="home-stretch">
          <rect class="blue-bg shape" x="70" y="10" width="10" height="10" />
          <rect class="blue-bg shape" x="70" y="20" width="10" height="10" />
          <rect class="blue-bg shape" x="70" y="30" width="10" height="10" />
          <rect class="blue-bg shape" x="70" y="40" width="10" height="10" />
          <rect class="blue-bg shape" x="70" y="50" width="10" height="10" />
          <rect class="red-bg shape" x="90" y="70" width="10" height="10" />
          <rect class="red-bg shape" x="100" y="70" width="10" height="10" />
          <rect class="red-bg shape" x="110" y="70" width="10" height="10" />
          <rect class="red-bg shape" x="120" y="70" width="10" height="10" />
          <rect class="red-bg shape" x="130" y="70" width="10" height="10" />
          <rect class="yellow-bg shape" x="70" y="90" width="10" height="10" />
          <rect class="yellow-bg shape" x="70" y="100" width="10" height="10" />
          <rect class="yellow-bg shape" x="70" y="110" width="10" height="10" />
          <rect class="yellow-bg shape" x="70" y="120" width="10" height="10" />
          <rect class="yellow-bg shape" x="70" y="130" width="10" height="10" />
          <rect class="green-bg shape" x="10" y="70" width="10" height="10" />
          <rect class="green-bg shape" x="20" y="70" width="10" height="10" />
          <rect class="green-bg shape" x="30" y="70" width="10" height="10" />
          <rect class="green-bg shape" x="40" y="70" width="10" height="10" />
          <rect class="green-bg shape" x="50" y="70" width="10" height="10" />
        </g>
        <g id="finish-area">
          <polygon class="blue-bg shape" points="60,60 90,60 75,75" />
          <polygon class="red-bg shape" points="90,60 90,90 75,75" />
          <polygon class="yellow-bg shape" points="90,90 60,90 75,75" />
          <polygon class="green-bg shape" points="60,90 60,60 75,75" />
        </g>
        <g id="pawns-container">
          <circle id="green-1" class="pawn green" cx="0" cy="0" r="4" />
          <circle id="green-2" class="pawn green" cx="0" cy="0" r="4" />
          <circle id="green-3" class="pawn green" cx="0" cy="0" r="4" />
          <circle id="green-4" class="pawn green" cx="0" cy="0" r="4" />
          <circle id="blue-1" class="pawn blue" cx="0" cy="0" r="4" />
          <circle id="blue-2" class="pawn blue" cx="0" cy="0" r="4" />
          <circle id="blue-3" class="pawn blue" cx="0" cy="0" r="4" />
          <circle id="blue-4" class="pawn blue" cx="0" cy="0" r="4" />
          <circle id="yellow-1" class="pawn yellow" cx="0" cy="0" r="4" />
          <circle id="yellow-2" class="pawn yellow" cx="0" cy="0" r="4" />
          <circle id="yellow-3" class="pawn yellow" cx="0" cy="0" r="4" />
          <circle id="yellow-4" class="pawn yellow" cx="0" cy="0" r="4" />
          <circle id="red-1" class="pawn red" cx="0" cy="0" r="4" />
          <circle id="red-2" class="pawn red" cx="0" cy="0" r="4" />
          <circle id="red-3" class="pawn red" cx="0" cy="0" r="4" />
          <circle id="red-4" class="pawn red" cx="0" cy="0" r="4" />
        </g>
      </svg>
    </div>
<script>

document.addEventListener('DOMContentLoaded', () => {
  class LudoGame {
    AI_THINK_TIME = 1500;
    AI_MOVE_DELAY = 1000;
    NO_MOVES_DELAY = 1500;
    NEXT_TURN_DELAY = 500;
    TEMP_MESSAGE_DURATION = 2500;
    COLORS = ['green', 'blue', 'red', 'yellow'];
    START_POSITIONS = {
      green: 1,
      blue: 14,
      red: 27,
      yellow: 40
    };
    HOME_STRETCH_LENGTH = 6;
    MAIN_PATH_LENGTH = 52;
    STEPS_TO_HOME_STRETCH = 51;
    PATH_COORDS = [null, {
      x: 15,
      y: 65
    }, {
      x: 25,
      y: 65
    }, {
      x: 35,
      y: 65
    }, {
      x: 45,
      y: 65
    }, {
      x: 55,
      y: 65
    }, {
      x: 65,
      y: 55
    }, {
      x: 65,
      y: 45
    }, {
      x: 65,
      y: 35
    }, {
      x: 65,
      y: 25
    }, {
      x: 65,
      y: 15
    }, {
      x: 65,
      y: 5
    }, {
      x: 75,
      y: 5
    }, {
      x: 85,
      y: 5
    }, {
      x: 85,
      y: 15
    }, {
      x: 85,
      y: 25
    }, {
      x: 85,
      y: 35
    }, {
      x: 85,
      y: 45
    }, {
      x: 85,
      y: 55
    }, {
      x: 95,
      y: 65
    }, {
      x: 105,
      y: 65
    }, {
      x: 115,
      y: 65
    }, {
      x: 125,
      y: 65
    }, {
      x: 135,
      y: 65
    }, {
      x: 145,
      y: 65
    }, {
      x: 145,
      y: 75
    }, {
      x: 145,
      y: 85
    }, {
      x: 135,
      y: 85
    }, {
      x: 125,
      y: 85
    }, {
      x: 115,
      y: 85
    }, {
      x: 105,
      y: 85
    }, {
      x: 95,
      y: 85
    }, {
      x: 85,
      y: 95
    }, {
      x: 85,
      y: 105
    }, {
      x: 85,
      y: 115
    }, {
      x: 85,
      y: 125
    }, {
      x: 85,
      y: 135
    }, {
      x: 85,
      y: 145
    }, {
      x: 75,
      y: 145
    }, {
      x: 65,
      y: 145
    }, {
      x: 65,
      y: 135
    }, {
      x: 65,
      y: 125
    }, {
      x: 65,
      y: 115
    }, {
      x: 65,
      y: 105
    }, {
      x: 65,
      y: 95
    }, {
      x: 55,
      y: 85
    }, {
      x: 45,
      y: 85
    }, {
      x: 35,
      y: 85
    }, {
      x: 25,
      y: 85
    }, {
      x: 15,
      y: 85
    }, {
      x: 5,
      y: 85
    }, {
      x: 5,
      y: 75
    }, {
      x: 5,
      y: 65
    }];
    HOME_STRETCH_COORDS = {
      green: [null, {
        x: 15,
        y: 75
      }, {
        x: 25,
        y: 75
      }, {
        x: 35,
        y: 75
      }, {
        x: 45,
        y: 75
      }, {
        x: 55,
        y: 75
      }, {
        x: 65,
        y: 75
      }],
      blue: [null, {
        x: 75,
        y: 15
      }, {
        x: 75,
        y: 25
      }, {
        x: 75,
        y: 35
      }, {
        x: 75,
        y: 45
      }, {
        x: 75,
        y: 55
      }, {
        x: 75,
        y: 65
      }],
      red: [null, {
        x: 135,
        y: 75
      }, {
        x: 125,
        y: 75
      }, {
        x: 115,
        y: 75
      }, {
        x: 105,
        y: 75
      }, {
        x: 95,
        y: 75
      }, {
        x: 85,
        y: 75
      }],
      yellow: [null, {
        x: 75,
        y: 135
      }, {
        x: 75,
        y: 125
      }, {
        x: 75,
        y: 115
      }, {
        x: 75,
        y: 105
      }, {
        x: 75,
        y: 95
      }, {
        x: 75,
        y: 85
      }]
    };
    HOME_YARD_COORDS = {
      green: [{
        x: 20,
        y: 20
      }, {
        x: 40,
        y: 20
      }, {
        x: 20,
        y: 40
      }, {
        x: 40,
        y: 40
      }],
      blue: [{
        x: 110,
        y: 20
      }, {
        x: 130,
        y: 20
      }, {
        x: 110,
        y: 40
      }, {
        x: 130,
        y: 40
      }],
      yellow: [{
        x: 20,
        y: 110
      }, {
        x: 40,
        y: 110
      }, {
        x: 20,
        y: 130
      }, {
        x: 40,
        y: 130
      }],
      red: [{
        x: 110,
        y: 110
      }, {
        x: 130,
        y: 110
      }, {
        x: 110,
        y: 130
      }, {
        x: 130,
        y: 130
      }]
    };
    constructor() {
      this.rollButton = document.getElementById('roll-button');
      this.diceDisplay = document.getElementById('dice');
      this.messageBox = document.getElementById('message-box');
      this.pawnsContainer = document.getElementById('pawns-container');
      this.winnerDisplay = document.getElementById('winner-display');
      this.autopilotButton = document.getElementById('autopilot-button');
      this.startGameButton = document.getElementById('start-game-button');
      this.gameStartOverlay = document.getElementById('game-start-overlay');
      this.state = {
        currentPlayerIndex: 0,
        diceValue: 0,
        pawns: {},
        isRolling: false,
        isAITurn: false,
        isGameOver: false,
        isAutopilotOn: false,
        rollsInCurrentTurn: 0,
        consecutiveSixes: 0
      };
      this.init();
    }
    init() {
      this.COLORS.forEach((color) => {
        for (let i = 1; i <= 4; i++) {
          const pawnId = `${color}-${i}`;
          this.state.pawns[pawnId] = {
            id: pawnId,
            color: color,
            position: 'home',
            pathIndex: 0
          };
        }
      });
      this.updateAllPawnPositions();
      this.adjustForStackedPawns();
      this.setupEventListeners();
      this.gameStartOverlay.style.display = 'flex';
      this.rollButton.disabled = true;
      this.autopilotButton.disabled = true;
    }
    determineFirstPlayer() {
      this.rollButton.disabled = true;
      this.autopilotButton.disabled = true;
      this.state.isRolling = true;
      this.messageBox.textContent = 'Rolling for first player...';
      let rollCount = 0;
      const initialRollInterval = setInterval(() => {
        this.diceDisplay.textContent = Math.floor(Math.random() * 6) + 1;
        if (++rollCount > 10) {
          clearInterval(initialRollInterval);
          const {
            startingIndex,
            highestRoll
          } = this._executeInitialRolls();
          this.state.currentPlayerIndex = startingIndex;
          const starterColor = this.COLORS[startingIndex];
          const starterName = starterColor.charAt(0).toUpperCase() + starterColor.slice(1);
          this.diceDisplay.textContent = highestRoll;
          this.messageBox.textContent = `Dice rolled! ${starterName} rolled highest (${highestRoll}) and starts.`;
          this.updateTurnDisplay();
          this.state.isRolling = false;
          this.autopilotButton.disabled = false;
          this.startNextPlayerTurn();
        }
      }, 100);
    }
    _executeInitialRolls() {
      let highestRoll = -1;
      let startingIndex = 0;
      for (let i = 0; i < 4; i++) {
        const roll = Math.floor(Math.random() * 6) + 1;
        if (roll > highestRoll) {
          highestRoll = roll;
          startingIndex = i;
        }
      }
      return {
        startingIndex,
        highestRoll
      };
    }
    handleStartGame() {
      this.gameStartOverlay.style.display = 'none';
      this.rollButton.disabled = false;
      this.autopilotButton.disabled = false;
      this.determineFirstPlayer();
    }
    setupEventListeners() {
      this.rollButton.addEventListener('click', () => this.rollDice());
      this.autopilotButton.addEventListener('click', () => this.toggleAutopilot());
      this.startGameButton.addEventListener('click', () => this.handleStartGame());
      this.pawnsContainer.addEventListener('click', (e) => {
        if (this.state.isGameOver || this.state.isAITurn) return;
        if (e.target.classList.contains('movable')) {
          this.movePawn(e.target.id);
        }
      });
    }
    toggleAutopilot() {
      this.state.isAutopilotOn = !this.state.isAutopilotOn;
      this.autopilotButton.classList.toggle('active', this.state.isAutopilotOn);
      this.autopilotButton.textContent = this.state.isAutopilotOn ? 'Autopilot ON' : 'Autopilot';
      if (this.state.isAutopilotOn && this.COLORS[this.state.currentPlayerIndex] === 'green' && !this.state.isRolling) {
        this.state.isAITurn = true;
        this.rollButton.disabled = true;
        this.startNextPlayerTurn();
      }
    }
    updateAllPawnPositions() {
      for (const pawnId in this.state.pawns) {
        this.updatePawnPosition(pawnId);
      }
    }
    updatePawnPosition(pawnId) {
      const pawn = this.state.pawns[pawnId];
      const el = document.getElementById(pawnId);
      if (!el) return;
      el.style.display = pawn.position === 'finished' ? 'none' : '';
      const coords = this.getPawnCoords(pawn);
      if (coords) {
        el.style.transform = `translate(${coords.x}px, ${coords.y}px)`;
      }
    }
    adjustForStackedPawns() {
      Object.values(this.state.pawns).forEach(pawn => {
        if (pawn.position !== 'finished' && pawn.position !== 'home') {
          const el = document.getElementById(pawn.id);
          if (el) {
            const coords = this.getPawnCoords(pawn);
            el.style.transform = `translate(${coords.x}px, ${coords.y}px)`;
          }
        }
      });
      const locations = new Map();
      Object.values(this.state.pawns).forEach(pawn => {
        if (pawn.position === 'finished' || pawn.position === 'home') return;
        let key = pawn.position === 'in-stretch' ?
          `${pawn.color}-${pawn.position}-${pawn.pathIndex}` :
          `${pawn.position}-${pawn.pathIndex}`;
        if (!locations.has(key)) {
          locations.set(key, []);
        }
        locations.get(key).push(pawn.id);
      });
      for (const pawnIdsOnSquare of locations.values()) {
        if (pawnIdsOnSquare.length > 1) {
          const angleStep = (2 * Math.PI) / pawnIdsOnSquare.length;
          const radius = 2.5;
          pawnIdsOnSquare.forEach((pawnId, index) => {
            const el = document.getElementById(pawnId);
            const pawn = this.state.pawns[pawnId];
            if (el) {
              const baseCoords = this.getPawnCoords(pawn);
              const dx = radius * Math.cos(index * angleStep);
              const dy = radius * Math.sin(index * angleStep);
              el.style.transform = `translate(${baseCoords.x}px, ${baseCoords.y}px) translate(${dx.toFixed(2)}px, ${dy.toFixed(2)}px)`;
            }
          });
        }
      }
    }
    getPawnCoords(pawn) {
      switch (pawn.position) {
        case 'home':
          return this.HOME_YARD_COORDS[pawn.color][parseInt(pawn.id.split('-')[1]) - 1];
        case 'in-play':
          return this.PATH_COORDS[pawn.pathIndex];
        case 'in-stretch':
          return this.HOME_STRETCH_COORDS[pawn.color][pawn.pathIndex];
        default:
          return null;
      }
    }
    updateTurnDisplay() {
      if (this.state.isGameOver) return;
      const color = this.COLORS[this.state.currentPlayerIndex];
      const playerName = color.charAt(0).toUpperCase() + color.slice(1);
      this.messageBox.textContent = `${playerName}'s Turn`;
      this.diceDisplay.style.borderColor = `var(--${color})`;
    }
    highlightMovablePawns(pawnIds, shouldHighlight) {
      document.querySelectorAll('.pawn').forEach(p => p.classList.remove('movable'));
      if (shouldHighlight) {
        pawnIds.forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.classList.add('movable');
            el.parentElement.appendChild(el);
          }
        });
      }
    }
    showTemporaryMessage(message, color) {
      this.winnerDisplay.textContent = message;
      this.winnerDisplay.style.color = `var(--${color})`;
      this.winnerDisplay.classList.add('show-message');
      setTimeout(() => {
        this.winnerDisplay.classList.remove('show-message');
      }, this.TEMP_MESSAGE_DURATION);
    }
    startNextPlayerTurn() {
      const currentPlayerColor = this.COLORS[this.state.currentPlayerIndex];
      this.state.isAITurn = currentPlayerColor !== 'green' || this.state.isAutopilotOn;
      this.rollButton.disabled = this.state.isAITurn || this.state.isRolling;
      if (this.state.isAITurn) {
        setTimeout(() => this.playAITurn(), this.AI_THINK_TIME);
      }
    }
    switchPlayer() {
      if (this.state.isGameOver) return;
      this.state.currentPlayerIndex = (this.state.currentPlayerIndex + 1) % this.COLORS.length;
      this.state.rollsInCurrentTurn = 0;
      this.state.consecutiveSixes = 0;
      this.updateTurnDisplay();
      this.startNextPlayerTurn();
    }
    rollDice() {
      if (this.state.isRolling || this.state.isGameOver) return;
      this.state.rollsInCurrentTurn++;
      this.state.isRolling = true;
      this.rollButton.disabled = true;
      let rollCount = 0;
      const interval = setInterval(() => {
        this.diceDisplay.textContent = Math.floor(Math.random() * 6) + 1;
        if (++rollCount > 5) {
          clearInterval(interval);
          this.state.diceValue = Math.floor(Math.random() * 6) + 1;
          this.diceDisplay.textContent = this.state.diceValue;
          this.state.isRolling = false;
          if (this.state.diceValue === 6) {
            this.state.consecutiveSixes++;
          } else {
            this.state.consecutiveSixes = 0;
          }
          this.handlePostRoll();
        }
      }, 100);
    }
    handlePostRoll() {
      if (this.state.diceValue === 6 && this.state.consecutiveSixes >= 3) {
        const nextPlayerColor = this.COLORS[(this.state.currentPlayerIndex + 1) % this.COLORS.length];
        this.messageBox.textContent = `Third 6! Turn passes.`;
        this.state.consecutiveSixes = 0;
        this.state.rollsInCurrentTurn = 0;
        setTimeout(() => this.switchPlayer(), this.NO_MOVES_DELAY);
        return;
      }
      const color = this.COLORS[this.state.currentPlayerIndex];
      const playerName = color.charAt(0).toUpperCase() + color.slice(1);
      this.messageBox.textContent = `${playerName} rolled ${this.state.diceValue}.`;
      const movablePawns = this.findMovablePawns(color, this.state.diceValue);
      if (movablePawns.length === 0) {
        const allPawnsAtHome = Object.values(this.state.pawns)
          .filter(p => p.color === color)
          .every(p => p.position === 'home');
        if (allPawnsAtHome && this.state.diceValue !== 6 && this.state.rollsInCurrentTurn < 3) {
          this.messageBox.textContent = `No 6. Roll again (${this.state.rollsInCurrentTurn}/3)`;
          this.state.isRolling = false;
          if (this.state.isAITurn) {
            setTimeout(() => this.playAITurn(), this.AI_MOVE_DELAY);
          } else {
            this.rollButton.disabled = false;
          }
        } else if (this.state.diceValue === 6) {
          this.messageBox.textContent += ` No moves, but rolled 6. Roll again!`;
          this.state.isRolling = false;
          if (this.state.isAITurn) {
            setTimeout(() => this.playAITurn(), this.AI_MOVE_DELAY);
          } else {
            this.rollButton.disabled = false;
          }
        } else {
          this.messageBox.textContent += ' No moves possible.';
          this.state.consecutiveSixes = 0;
          this.state.rollsInCurrentTurn = 0;
          setTimeout(() => this.switchPlayer(), this.NO_MOVES_DELAY);
        }
      } else {
        if (this.state.isAITurn) {
          const chosenPawnId = this.chooseAIPawn(movablePawns, this.state.diceValue, color);
          setTimeout(() => this.movePawn(chosenPawnId), this.AI_MOVE_DELAY);
        } else {
          this.highlightMovablePawns(movablePawns, true);
        }
      }
    }
    calculateNewPosition(pawn, dice) {
      if (pawn.position === 'home') {
        if (dice !== 6) return {
          position: pawn.position,
          pathIndex: pawn.pathIndex
        };
        return {
          position: 'in-play',
          pathIndex: this.START_POSITIONS[pawn.color]
        };
      }
      if (pawn.position === 'in-stretch') {
        const newIndex = pawn.pathIndex + dice;
        if (newIndex > this.HOME_STRETCH_LENGTH) {
          return {
            position: null,
            pathIndex: null
          };
        }
        for (let i = pawn.pathIndex + 1; i < newIndex; i++) {
          const blockers = Object.values(this.state.pawns).filter(p =>
            p.color === pawn.color &&
            p.position === 'in-stretch' &&
            p.pathIndex === i
          );
          if (blockers.length > 0) {
            return {
              position: null,
              pathIndex: null
            };
          }
        }
        return {
          position: newIndex === this.HOME_STRETCH_LENGTH ? 'finished' : 'in-stretch',
          pathIndex: newIndex
        };
      }
      if (pawn.position === 'in-play') {
        const currentRelativePos = this.getRelativeBoardPosition(pawn);
        const newRelativePos = currentRelativePos + dice;
        if (newRelativePos >= this.STEPS_TO_HOME_STRETCH) {
          const stretchIndex = newRelativePos - this.STEPS_TO_HOME_STRETCH + 1;
          if (stretchIndex > this.HOME_STRETCH_LENGTH) {
            return {
              position: null,
              pathIndex: null
            };
          }
          return {
            position: stretchIndex === this.HOME_STRETCH_LENGTH ? 'finished' : 'in-stretch',
            pathIndex: stretchIndex
          };
        } else {
          let newAbsIndex = (pawn.pathIndex + dice - 1) % this.MAIN_PATH_LENGTH + 1;
          return {
            position: 'in-play',
            pathIndex: newAbsIndex
          };
        }
      }
      return {
        position: pawn.position,
        pathIndex: pawn.pathIndex
      };
    }
    _isBlock(pathIndex, position, color) {
      if (position === 'in-stretch' || position === 'finished') return false;
      const pawnsOnSquare = this.getPawnsOnSquare(pathIndex, position);
      const pawnsOfSameColor = pawnsOnSquare.filter(p => p.color === color);
      return pawnsOfSameColor.length >= 2;
    }
    chooseAIPawn(movablePawns, dice, color) {
      if (movablePawns.length === 1) return movablePawns[0];
      const scoredMoves = movablePawns.map(pawnId => {
        const pawn = this.state.pawns[pawnId];
        const {
          position: newPosition,
          pathIndex: newPathIndex
        } = this.calculateNewPosition(pawn, dice);
        let score = 0;
        if (newPosition === 'finished') score += 1000;
        if (newPosition === 'in-play') {
          const opponents = this.getPawnsOnSquare(newPathIndex, 'in-play').filter(p => p.color !== color);
          if (opponents.length === 1) {
            const isSafe = this.START_POSITIONS[opponents[0].color] === opponents[0].pathIndex;
            if (!isSafe) score += 500;
          }
        }
        if (pawn.position === 'home' && dice === 6) score += 200;
        if (newPosition === 'in-play') {
          const own = this.getPawnsOnSquare(newPathIndex, 'in-play').filter(p => p.color === color && p.id !== pawnId);
          if (own.length === 1) score += 150;
        }
        if (newPosition === 'in-play') {
          const opponents = this.getPawnsOnSquare(newPathIndex, 'in-play').filter(p => p.color !== color);
          if (opponents.length >= 2) score -= 2000;
        }
        const progress = this.getRelativeBoardPosition(pawn);
        score += progress;
        return {
          pawnId,
          score
        };
      });
      scoredMoves.sort((a, b) => b.score - a.score);
      return scoredMoves[0].pawnId;
    }
    movePawn(pawnId) {
      this.highlightMovablePawns([], false);
      this.rollButton.disabled = true;
      const pawn = this.state.pawns[pawnId];
      const {
        position: newPosition,
        pathIndex: newPathIndex
      } = this.calculateNewPosition(pawn, this.state.diceValue);
      if (newPosition === null) {
        this.finishMove(false);
        return;
      }
      pawn.position = newPosition;
      pawn.pathIndex = newPathIndex;
      this.updatePawnPosition(pawnId);
      if (pawn.position === 'in-play' || pawn.position === 'in-stretch') {
        this.handleLanding(pawn);
      }
      if (pawn.position === 'finished') {
        pawn.pathIndex = 0;
        this.showTemporaryMessage('Finished!', pawn.color);
        const el = document.getElementById(pawnId);
        if (el) {
          const finalStretchCoords = this.HOME_STRETCH_COORDS[pawn.color][this.HOME_STRETCH_LENGTH];
          el.classList.add('finished-animation');
          setTimeout(() => el.style.display = 'none', 500);
        }
      }
      this.adjustForStackedPawns();
      if (this.checkWinner(pawn.color)) {
        this.state.isGameOver = true;
        this.rollButton.disabled = true;
        this.autopilotButton.disabled = true;
        this.messageBox.innerHTML = `Game Over! <a href="javascript:window.location.reload()">üîÅ Play Again</a>`;
        const winnerName = pawn.color.charAt(0).toUpperCase() + pawn.color.slice(1);
        this.showTemporaryMessage(`${winnerName} wins!`, pawn.color);
      } else {
        this.finishMove(this.state.diceValue === 6);
      }
    }
    finishMove(bonusRoll) {
      if (bonusRoll) {
        this.messageBox.textContent = `Bonus roll!`;
        this.state.isRolling = false;
        if (this.state.isAITurn) {
          setTimeout(() => this.playAITurn(), this.AI_MOVE_DELAY);
        } else {
          this.rollButton.disabled = false;
        }
      } else {
        this.state.consecutiveSixes = 0;
        this.state.rollsInCurrentTurn = 0;
        setTimeout(() => this.switchPlayer(), this.NEXT_TURN_DELAY);
      }
    }
    findMovablePawns(color, dice) {
      return Object.values(this.state.pawns)
        .filter(p => p.color === color && p.position !== 'finished')
        .filter(pawn => {
          if (pawn.position === 'home') {
            if (dice !== 6) return false;
            const startPos = this.START_POSITIONS[color];
            const pawnsOnStart = this.getPawnsOnSquare(startPos, 'in-play');
            const ownPawnsOnStart = pawnsOnStart.filter(p => p.color === color);
            return ownPawnsOnStart.length < 2;
          }
          const {
            position: newPos,
            pathIndex: newIndex
          } = this.calculateNewPosition(pawn, dice);
          if (newPos === null) return false;
          if (newPos === 'finished') return true;
          const occupyingPawns = this.getPawnsOnSquare(newIndex, newPos);
          const ownPawnsOnNewSquare = occupyingPawns.filter(p => p.color === color);
          if (ownPawnsOnNewSquare.length >= 2) return false;
          return true;
        })
        .map(p => p.id);
    }
    getRelativeBoardPosition(pawn) {
      if (pawn.position !== 'in-play') return -1;
      const startPoint = this.START_POSITIONS[pawn.color];
      return (pawn.pathIndex - startPoint + this.MAIN_PATH_LENGTH) % this.MAIN_PATH_LENGTH;
    }
    getPawnsOnSquare(pathIndex, position) {
      return Object.values(this.state.pawns).filter(p => p.position === position && p.pathIndex === pathIndex);
    }
    handleLanding(movedPawn) {
      const pawnsOnLandedSquare = this.getPawnsOnSquare(movedPawn.pathIndex, movedPawn.position);
      const others = pawnsOnLandedSquare.filter(p => p.id !== movedPawn.id);
      const opponentPawns = others.filter(p => p.color !== movedPawn.color);
      if (movedPawn.position === 'in-play' && opponentPawns.length >= 2) {
        const movedPlayerName = movedPawn.color.charAt(0).toUpperCase() + movedPawn.color.slice(1);
        this.messageBox.textContent = `${movedPlayerName} hit a block! Bounced home.`;
        movedPawn.position = 'home';
        movedPawn.pathIndex = 0;
        this.updatePawnPosition(movedPawn.id);
        return;
      }
      let knockedOutMessage = false;
      for (const pawnToKnock of others) {
        if (pawnToKnock.color !== movedPawn.color) {
          const isPawnSafe = this.START_POSITIONS[pawnToKnock.color] === pawnToKnock.pathIndex || pawnToKnock.position === 'in-stretch';
          if (!isPawnSafe) {
            pawnToKnock.position = 'home';
            pawnToKnock.pathIndex = 0;
            this.updatePawnPosition(pawnToKnock.id);
            if (!knockedOutMessage) {
              const movedPlayerName = movedPawn.color.charAt(0).toUpperCase() + movedPawn.color.slice(1);
              const knockedPlayerName = pawnToKnock.color.charAt(0).toUpperCase() + pawnToKnock.color.slice(1);
              this.messageBox.textContent = `${movedPlayerName} knocked out ${knockedPlayerName}!`;
              knockedOutMessage = true;
            }
          }
        }
      }
    }
    checkWinner(color) {
      return Object.values(this.state.pawns)
        .filter(p => p.color === color)
        .every(p => p.position === 'finished');
    }
    playAITurn() {
      if (this.state.isGameOver) return;
      this.rollDice();
    }
  }
  new LudoGame();
});

</script>
  </body>
</html>